// This file was auto-generated by codegen! Do not edit!

use crate::{Result, SonosDevice};
use std::str::FromStr;

/// Request and Response types for the `AVTransport` service.
pub mod av_transport {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `AVTransport` service.
    /// `urn:schemas-upnp-org:service:AVTransport:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:AVTransport:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddMultipleURIsToQueue", ns(SERVICE_TYPE))]
    pub struct AddMultipleUrisToQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        #[xml(rename = "NumberOfURIs", ns(""))]
        pub number_of_uris: u32,
        #[xml(rename = "EnqueuedURIs", ns(""))]
        pub enqueued_uris: String,
        #[xml(rename = "EnqueuedURIsMetaData", ns(""))]
        pub enqueued_uris_meta_data: String,
        #[xml(rename = "ContainerURI", ns(""))]
        pub container_uri: String,
        #[xml(rename = "ContainerMetaData", ns(""))]
        pub container_meta_data: String,
        #[xml(rename = "DesiredFirstTrackNumberEnqueued", ns(""))]
        pub desired_first_track_number_enqueued: u32,
        #[xml(rename = "EnqueueAsNext", ns(""))]
        pub enqueue_as_next: bool,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddMultipleURIsToQueueResponse", ns(SERVICE_TYPE))]
    pub struct AddMultipleUrisToQueueResponse {
        #[xml(rename = "FirstTrackNumberEnqueued", ns(""))]
        pub first_track_number_enqueued: Option<u32>,
        #[xml(rename = "NumTracksAdded", ns(""))]
        pub num_tracks_added: Option<u32>,
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for AddMultipleUrisToQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddURIToQueue", ns(SERVICE_TYPE))]
    pub struct AddUriToQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "EnqueuedURI", ns(""))]
        pub enqueued_uri: String,
        #[xml(rename = "EnqueuedURIMetaData", ns(""))]
        pub enqueued_uri_meta_data: String,
        /// use `0` to add at the end or `1` to insert at the beginning
        #[xml(rename = "DesiredFirstTrackNumberEnqueued", ns(""))]
        pub desired_first_track_number_enqueued: u32,
        #[xml(rename = "EnqueueAsNext", ns(""))]
        pub enqueue_as_next: bool,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddURIToQueueResponse", ns(SERVICE_TYPE))]
    pub struct AddUriToQueueResponse {
        #[xml(rename = "FirstTrackNumberEnqueued", ns(""))]
        pub first_track_number_enqueued: Option<u32>,
        #[xml(rename = "NumTracksAdded", ns(""))]
        pub num_tracks_added: Option<u32>,
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
    }

    impl crate::DecodeSoapResponse for AddUriToQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddURIToSavedQueue", ns(SERVICE_TYPE))]
    pub struct AddUriToSavedQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        #[xml(rename = "EnqueuedURI", ns(""))]
        pub enqueued_uri: String,
        #[xml(rename = "EnqueuedURIMetaData", ns(""))]
        pub enqueued_uri_meta_data: String,
        #[xml(rename = "AddAtIndex", ns(""))]
        pub add_at_index: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddURIToSavedQueueResponse", ns(SERVICE_TYPE))]
    pub struct AddUriToSavedQueueResponse {
        #[xml(rename = "NumTracksAdded", ns(""))]
        pub num_tracks_added: Option<u32>,
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for AddUriToSavedQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "BackupQueue", ns(SERVICE_TYPE))]
    pub struct BackupQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "BecomeCoordinatorOfStandaloneGroup", ns(SERVICE_TYPE))]
    pub struct BecomeCoordinatorOfStandaloneGroupRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(
        rename = "BecomeCoordinatorOfStandaloneGroupResponse",
        ns(SERVICE_TYPE)
    )]
    pub struct BecomeCoordinatorOfStandaloneGroupResponse {
        #[xml(rename = "DelegatedGroupCoordinatorID", ns(""))]
        pub delegated_group_coordinator_id: Option<String>,
        #[xml(rename = "NewGroupID", ns(""))]
        pub new_group_id: Option<String>,
    }

    impl crate::DecodeSoapResponse for BecomeCoordinatorOfStandaloneGroupResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "BecomeGroupCoordinator", ns(SERVICE_TYPE))]
    pub struct BecomeGroupCoordinatorRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "CurrentCoordinator", ns(""))]
        pub current_coordinator: String,
        #[xml(rename = "CurrentGroupID", ns(""))]
        pub current_group_id: String,
        #[xml(rename = "OtherMembers", ns(""))]
        pub other_members: String,
        #[xml(rename = "TransportSettings", ns(""))]
        pub transport_settings: String,
        #[xml(rename = "CurrentURI", ns(""))]
        pub current_uri: String,
        #[xml(rename = "CurrentURIMetaData", ns(""))]
        pub current_uri_meta_data: String,
        #[xml(rename = "SleepTimerState", ns(""))]
        pub sleep_timer_state: String,
        #[xml(rename = "AlarmState", ns(""))]
        pub alarm_state: String,
        #[xml(rename = "StreamRestartState", ns(""))]
        pub stream_restart_state: String,
        #[xml(rename = "CurrentQueueTrackList", ns(""))]
        pub current_queue_track_list: String,
        #[xml(rename = "CurrentVLIState", ns(""))]
        pub current_vli_state: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "BecomeGroupCoordinatorAndSource", ns(SERVICE_TYPE))]
    pub struct BecomeGroupCoordinatorAndSourceRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "CurrentCoordinator", ns(""))]
        pub current_coordinator: String,
        #[xml(rename = "CurrentGroupID", ns(""))]
        pub current_group_id: String,
        #[xml(rename = "OtherMembers", ns(""))]
        pub other_members: String,
        #[xml(rename = "CurrentURI", ns(""))]
        pub current_uri: String,
        #[xml(rename = "CurrentURIMetaData", ns(""))]
        pub current_uri_meta_data: String,
        #[xml(rename = "SleepTimerState", ns(""))]
        pub sleep_timer_state: String,
        #[xml(rename = "AlarmState", ns(""))]
        pub alarm_state: String,
        #[xml(rename = "StreamRestartState", ns(""))]
        pub stream_restart_state: String,
        #[xml(rename = "CurrentAVTTrackList", ns(""))]
        pub current_avt_track_list: String,
        #[xml(rename = "CurrentQueueTrackList", ns(""))]
        pub current_queue_track_list: String,
        #[xml(rename = "CurrentSourceState", ns(""))]
        pub current_source_state: String,
        #[xml(rename = "ResumePlayback", ns(""))]
        pub resume_playback: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ChangeCoordinator", ns(SERVICE_TYPE))]
    pub struct ChangeCoordinatorRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "CurrentCoordinator", ns(""))]
        pub current_coordinator: String,
        #[xml(rename = "NewCoordinator", ns(""))]
        pub new_coordinator: String,
        #[xml(rename = "NewTransportSettings", ns(""))]
        pub new_transport_settings: String,
        #[xml(rename = "CurrentAVTransportURI", ns(""))]
        pub current_av_transport_uri: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ChangeTransportSettings", ns(SERVICE_TYPE))]
    pub struct ChangeTransportSettingsRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "NewTransportSettings", ns(""))]
        pub new_transport_settings: String,
        #[xml(rename = "CurrentAVTransportURI", ns(""))]
        pub current_av_transport_uri: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ConfigureSleepTimer", ns(SERVICE_TYPE))]
    pub struct ConfigureSleepTimerRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// Time to stop after, as `hh:mm:ss` or empty string to cancel
        #[xml(rename = "NewSleepTimerDuration", ns(""))]
        pub new_sleep_timer_duration: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "CreateSavedQueue", ns(SERVICE_TYPE))]
    pub struct CreateSavedQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Title", ns(""))]
        pub title: String,
        #[xml(rename = "EnqueuedURI", ns(""))]
        pub enqueued_uri: String,
        #[xml(rename = "EnqueuedURIMetaData", ns(""))]
        pub enqueued_uri_meta_data: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "CreateSavedQueueResponse", ns(SERVICE_TYPE))]
    pub struct CreateSavedQueueResponse {
        #[xml(rename = "NumTracksAdded", ns(""))]
        pub num_tracks_added: Option<u32>,
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
        #[xml(rename = "AssignedObjectID", ns(""))]
        pub assigned_object_id: Option<String>,
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for CreateSavedQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "DelegateGroupCoordinationTo", ns(SERVICE_TYPE))]
    pub struct DelegateGroupCoordinationToRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// uuid of the new coordinator - must be in same group
        #[xml(rename = "NewCoordinator", ns(""))]
        pub new_coordinator: String,
        /// Should former coordinator rejoin the group?
        #[xml(rename = "RejoinGroup", ns(""))]
        pub rejoin_group: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "EndDirectControlSession", ns(SERVICE_TYPE))]
    pub struct EndDirectControlSessionRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetCrossfadeMode", ns(SERVICE_TYPE))]
    pub struct GetCrossfadeModeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetCrossfadeModeResponse", ns(SERVICE_TYPE))]
    pub struct GetCrossfadeModeResponse {
        #[xml(rename = "CrossfadeMode", ns(""))]
        pub crossfade_mode: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetCrossfadeModeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetCurrentTransportActions", ns(SERVICE_TYPE))]
    pub struct GetCurrentTransportActionsRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetCurrentTransportActionsResponse", ns(SERVICE_TYPE))]
    pub struct GetCurrentTransportActionsResponse {
        #[xml(rename = "Actions", ns(""))]
        pub actions: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetCurrentTransportActionsResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetDeviceCapabilities", ns(SERVICE_TYPE))]
    pub struct GetDeviceCapabilitiesRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetDeviceCapabilitiesResponse", ns(SERVICE_TYPE))]
    pub struct GetDeviceCapabilitiesResponse {
        #[xml(rename = "PlayMedia", ns(""))]
        pub play_media: Option<String>,
        #[xml(rename = "RecMedia", ns(""))]
        pub rec_media: Option<String>,
        #[xml(rename = "RecQualityModes", ns(""))]
        pub rec_quality_modes: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetDeviceCapabilitiesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetMediaInfo", ns(SERVICE_TYPE))]
    pub struct GetMediaInfoRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetMediaInfoResponse", ns(SERVICE_TYPE))]
    pub struct GetMediaInfoResponse {
        #[xml(rename = "NrTracks", ns(""))]
        pub nr_tracks: Option<u32>,
        #[xml(rename = "MediaDuration", ns(""))]
        pub media_duration: Option<String>,
        #[xml(rename = "CurrentURI", ns(""))]
        pub current_uri: Option<String>,
        #[xml(rename = "CurrentURIMetaData", ns(""))]
        pub current_uri_meta_data: Option<String>,
        #[xml(rename = "NextURI", ns(""))]
        pub next_uri: Option<String>,
        #[xml(rename = "NextURIMetaData", ns(""))]
        pub next_uri_meta_data: Option<String>,
        #[xml(rename = "PlayMedium", ns(""))]
        pub play_medium: Option<super::PlaybackStorageMedium>,
        #[xml(rename = "RecordMedium", ns(""))]
        pub record_medium: Option<String>,
        #[xml(rename = "WriteStatus", ns(""))]
        pub write_status: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetMediaInfoResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetPositionInfo", ns(SERVICE_TYPE))]
    pub struct GetPositionInfoRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetPositionInfoResponse", ns(SERVICE_TYPE))]
    pub struct GetPositionInfoResponse {
        #[xml(rename = "Track", ns(""))]
        pub track: Option<u32>,
        #[xml(rename = "TrackDuration", ns(""))]
        pub track_duration: Option<String>,
        #[xml(rename = "TrackMetaData", ns(""))]
        pub track_meta_data: Option<crate::xmlutil::DecodeXmlString<crate::TrackMetaData>>,
        #[xml(rename = "TrackURI", ns(""))]
        pub track_uri: Option<String>,
        #[xml(rename = "RelTime", ns(""))]
        pub rel_time: Option<String>,
        #[xml(rename = "AbsTime", ns(""))]
        pub abs_time: Option<String>,
        #[xml(rename = "RelCount", ns(""))]
        pub rel_count: Option<i32>,
        #[xml(rename = "AbsCount", ns(""))]
        pub abs_count: Option<i32>,
    }

    impl crate::DecodeSoapResponse for GetPositionInfoResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetRemainingSleepTimerDuration", ns(SERVICE_TYPE))]
    pub struct GetRemainingSleepTimerDurationRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetRemainingSleepTimerDurationResponse", ns(SERVICE_TYPE))]
    pub struct GetRemainingSleepTimerDurationResponse {
        #[xml(rename = "RemainingSleepTimerDuration", ns(""))]
        pub remaining_sleep_timer_duration: Option<String>,
        #[xml(rename = "CurrentSleepTimerGeneration", ns(""))]
        pub current_sleep_timer_generation: Option<u32>,
    }

    impl crate::DecodeSoapResponse for GetRemainingSleepTimerDurationResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetRunningAlarmProperties", ns(SERVICE_TYPE))]
    pub struct GetRunningAlarmPropertiesRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetRunningAlarmPropertiesResponse", ns(SERVICE_TYPE))]
    pub struct GetRunningAlarmPropertiesResponse {
        #[xml(rename = "AlarmID", ns(""))]
        pub alarm_id: Option<u32>,
        #[xml(rename = "GroupID", ns(""))]
        pub group_id: Option<String>,
        #[xml(rename = "LoggedStartTime", ns(""))]
        pub logged_start_time: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetRunningAlarmPropertiesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetTransportInfo", ns(SERVICE_TYPE))]
    pub struct GetTransportInfoRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTransportInfoResponse", ns(SERVICE_TYPE))]
    pub struct GetTransportInfoResponse {
        #[xml(rename = "CurrentTransportState", ns(""))]
        pub current_transport_state: Option<super::TransportState>,
        #[xml(rename = "CurrentTransportStatus", ns(""))]
        pub current_transport_status: Option<String>,
        #[xml(rename = "CurrentSpeed", ns(""))]
        pub current_speed: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetTransportInfoResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetTransportSettings", ns(SERVICE_TYPE))]
    pub struct GetTransportSettingsRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTransportSettingsResponse", ns(SERVICE_TYPE))]
    pub struct GetTransportSettingsResponse {
        #[xml(rename = "PlayMode", ns(""))]
        pub play_mode: Option<super::CurrentPlayMode>,
        #[xml(rename = "RecQualityMode", ns(""))]
        pub rec_quality_mode: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetTransportSettingsResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Next", ns(SERVICE_TYPE))]
    pub struct NextRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "NotifyDeletedURI", ns(SERVICE_TYPE))]
    pub struct NotifyDeletedUriRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "DeletedURI", ns(""))]
        pub deleted_uri: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Pause", ns(SERVICE_TYPE))]
    pub struct PauseRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Play", ns(SERVICE_TYPE))]
    pub struct PlayRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// Play speed usually 1, can be a fraction of 1
        #[xml(rename = "Speed", ns(""))]
        pub speed: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Previous", ns(SERVICE_TYPE))]
    pub struct PreviousRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveAllTracksFromQueue", ns(SERVICE_TYPE))]
    pub struct RemoveAllTracksFromQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveTrackFromQueue", ns(SERVICE_TYPE))]
    pub struct RemoveTrackFromQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveTrackRangeFromQueue", ns(SERVICE_TYPE))]
    pub struct RemoveTrackRangeFromQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// Leave blank
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        /// between 1 and queue-length
        #[xml(rename = "StartingIndex", ns(""))]
        pub starting_index: u32,
        #[xml(rename = "NumberOfTracks", ns(""))]
        pub number_of_tracks: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "RemoveTrackRangeFromQueueResponse", ns(SERVICE_TYPE))]
    pub struct RemoveTrackRangeFromQueueResponse {
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for RemoveTrackRangeFromQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ReorderTracksInQueue", ns(SERVICE_TYPE))]
    pub struct ReorderTracksInQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "StartingIndex", ns(""))]
        pub starting_index: u32,
        #[xml(rename = "NumberOfTracks", ns(""))]
        pub number_of_tracks: u32,
        #[xml(rename = "InsertBefore", ns(""))]
        pub insert_before: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ReorderTracksInSavedQueue", ns(SERVICE_TYPE))]
    pub struct ReorderTracksInSavedQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        #[xml(rename = "TrackList", ns(""))]
        pub track_list: String,
        #[xml(rename = "NewPositionList", ns(""))]
        pub new_position_list: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "ReorderTracksInSavedQueueResponse", ns(SERVICE_TYPE))]
    pub struct ReorderTracksInSavedQueueResponse {
        #[xml(rename = "QueueLengthChange", ns(""))]
        pub queue_length_change: Option<i32>,
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for ReorderTracksInSavedQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RunAlarm", ns(SERVICE_TYPE))]
    pub struct RunAlarmRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "AlarmID", ns(""))]
        pub alarm_id: u32,
        #[xml(rename = "LoggedStartTime", ns(""))]
        pub logged_start_time: String,
        #[xml(rename = "Duration", ns(""))]
        pub duration: String,
        #[xml(rename = "ProgramURI", ns(""))]
        pub program_uri: String,
        #[xml(rename = "ProgramMetaData", ns(""))]
        pub program_meta_data: String,
        #[xml(rename = "PlayMode", ns(""))]
        pub play_mode: super::CurrentPlayMode,
        #[xml(rename = "Volume", ns(""))]
        pub volume: u16,
        #[xml(rename = "IncludeLinkedZones", ns(""))]
        pub include_linked_zones: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SaveQueue", ns(SERVICE_TYPE))]
    pub struct SaveQueueRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// SONOS playlist title
        #[xml(rename = "Title", ns(""))]
        pub title: String,
        /// Leave blank
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "SaveQueueResponse", ns(SERVICE_TYPE))]
    pub struct SaveQueueResponse {
        #[xml(rename = "AssignedObjectID", ns(""))]
        pub assigned_object_id: Option<String>,
    }

    impl crate::DecodeSoapResponse for SaveQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Seek", ns(SERVICE_TYPE))]
    pub struct SeekRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// What to seek
        #[xml(rename = "Unit", ns(""))]
        pub unit: super::SeekMode,
        /// Position of track in queue (start at 1) or `hh:mm:ss` for `REL_TIME` or `+/-hh:mm:ss` for `TIME_DELTA`
        #[xml(rename = "Target", ns(""))]
        pub target: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetAVTransportURI", ns(SERVICE_TYPE))]
    pub struct SetAvTransportUriRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// The new TransportURI - its a special SONOS format
        #[xml(rename = "CurrentURI", ns(""))]
        pub current_uri: String,
        /// Track Metadata, see MetadataHelper.GuessTrack to guess based on track uri
        #[xml(rename = "CurrentURIMetaData", ns(""))]
        pub current_uri_meta_data: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetCrossfadeMode", ns(SERVICE_TYPE))]
    pub struct SetCrossfadeModeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "CrossfadeMode", ns(""))]
        pub crossfade_mode: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetNextAVTransportURI", ns(SERVICE_TYPE))]
    pub struct SetNextAvTransportUriRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "NextURI", ns(""))]
        pub next_uri: String,
        #[xml(rename = "NextURIMetaData", ns(""))]
        pub next_uri_meta_data: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetPlayMode", ns(SERVICE_TYPE))]
    pub struct SetPlayModeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// New playmode
        #[xml(rename = "NewPlayMode", ns(""))]
        pub new_play_mode: super::CurrentPlayMode,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SnoozeAlarm", ns(SERVICE_TYPE))]
    pub struct SnoozeAlarmRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// Snooze time as `hh:mm:ss`, 10 minutes = 00:10:00
        #[xml(rename = "Duration", ns(""))]
        pub duration: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "StartAutoplay", ns(SERVICE_TYPE))]
    pub struct StartAutoplayRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "ProgramURI", ns(""))]
        pub program_uri: String,
        #[xml(rename = "ProgramMetaData", ns(""))]
        pub program_meta_data: String,
        #[xml(rename = "Volume", ns(""))]
        pub volume: u16,
        #[xml(rename = "IncludeLinkedZones", ns(""))]
        pub include_linked_zones: bool,
        #[xml(rename = "ResetVolumeAfter", ns(""))]
        pub reset_volume_after: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Stop", ns(SERVICE_TYPE))]
    pub struct StopRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    /// A parsed event produced by the `AVTransport` service.
    /// Use `SonosDevice::subscribe_av_transport()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct AVTransportEvent {
        pub last_change: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct AVTransportPropertySet {
        pub properties: Vec<AVTransportProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct AVTransportProperty {
        #[xml(rename = "LastChange", ns(""))]
        pub last_change: Option<String>,
    }

    impl crate::upnp::DecodeXml for AVTransportEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: AVTransportPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.last_change {
                    result.last_change.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `AVTransport` service on this device
        pub async fn subscribe_av_transport(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<AVTransportEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum SeekMode {
    #[default]
    TrackNr,
    RelTime,
    TimeDelta,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for SeekMode {
    fn to_string(&self) -> String {
        match self {
            SeekMode::TrackNr => "TRACK_NR".to_string(),
            SeekMode::RelTime => "REL_TIME".to_string(),
            SeekMode::TimeDelta => "TIME_DELTA".to_string(),
            SeekMode::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for SeekMode {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<SeekMode> {
        match s {
            "TRACK_NR" => Ok(SeekMode::TrackNr),
            "REL_TIME" => Ok(SeekMode::RelTime),
            "TIME_DELTA" => Ok(SeekMode::TimeDelta),
            s => Ok(SeekMode::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for SeekMode {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for SeekMode {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: SeekMode = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<SeekMode>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum CurrentPlayMode {
    #[default]
    Normal,
    RepeatAll,
    RepeatOne,
    ShuffleNorepeat,
    Shuffle,
    ShuffleRepeatOne,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for CurrentPlayMode {
    fn to_string(&self) -> String {
        match self {
            CurrentPlayMode::Normal => "NORMAL".to_string(),
            CurrentPlayMode::RepeatAll => "REPEAT_ALL".to_string(),
            CurrentPlayMode::RepeatOne => "REPEAT_ONE".to_string(),
            CurrentPlayMode::ShuffleNorepeat => "SHUFFLE_NOREPEAT".to_string(),
            CurrentPlayMode::Shuffle => "SHUFFLE".to_string(),
            CurrentPlayMode::ShuffleRepeatOne => "SHUFFLE_REPEAT_ONE".to_string(),
            CurrentPlayMode::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for CurrentPlayMode {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<CurrentPlayMode> {
        match s {
            "NORMAL" => Ok(CurrentPlayMode::Normal),
            "REPEAT_ALL" => Ok(CurrentPlayMode::RepeatAll),
            "REPEAT_ONE" => Ok(CurrentPlayMode::RepeatOne),
            "SHUFFLE_NOREPEAT" => Ok(CurrentPlayMode::ShuffleNorepeat),
            "SHUFFLE" => Ok(CurrentPlayMode::Shuffle),
            "SHUFFLE_REPEAT_ONE" => Ok(CurrentPlayMode::ShuffleRepeatOne),
            s => Ok(CurrentPlayMode::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for CurrentPlayMode {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for CurrentPlayMode {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: CurrentPlayMode = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<CurrentPlayMode>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum PlaybackStorageMedium {
    #[default]
    None,
    Network,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for PlaybackStorageMedium {
    fn to_string(&self) -> String {
        match self {
            PlaybackStorageMedium::None => "NONE".to_string(),
            PlaybackStorageMedium::Network => "NETWORK".to_string(),
            PlaybackStorageMedium::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for PlaybackStorageMedium {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<PlaybackStorageMedium> {
        match s {
            "NONE" => Ok(PlaybackStorageMedium::None),
            "NETWORK" => Ok(PlaybackStorageMedium::Network),
            s => Ok(PlaybackStorageMedium::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for PlaybackStorageMedium {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for PlaybackStorageMedium {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: PlaybackStorageMedium = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<PlaybackStorageMedium>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum TransportState {
    #[default]
    Stopped,
    Playing,
    PausedPlayback,
    Transitioning,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for TransportState {
    fn to_string(&self) -> String {
        match self {
            TransportState::Stopped => "STOPPED".to_string(),
            TransportState::Playing => "PLAYING".to_string(),
            TransportState::PausedPlayback => "PAUSED_PLAYBACK".to_string(),
            TransportState::Transitioning => "TRANSITIONING".to_string(),
            TransportState::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for TransportState {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<TransportState> {
        match s {
            "STOPPED" => Ok(TransportState::Stopped),
            "PLAYING" => Ok(TransportState::Playing),
            "PAUSED_PLAYBACK" => Ok(TransportState::PausedPlayback),
            "TRANSITIONING" => Ok(TransportState::Transitioning),
            s => Ok(TransportState::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for TransportState {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for TransportState {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: TransportState = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<TransportState>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

/// Request and Response types for the `AlarmClock` service.
pub mod alarm_clock {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `AlarmClock` service.
    /// `urn:schemas-upnp-org:service:AlarmClock:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:AlarmClock:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "CreateAlarm", ns(SERVICE_TYPE))]
    pub struct CreateAlarmRequest {
        /// The start time as `hh:mm:ss`
        #[xml(rename = "StartLocalTime", ns(""))]
        pub start_local_time: String,
        /// The duration as `hh:mm:ss`
        #[xml(rename = "Duration", ns(""))]
        pub duration: String,
        /// Repeat this alarm on
        #[xml(rename = "Recurrence", ns(""))]
        pub recurrence: super::Recurrence,
        /// Alarm enabled after creation
        #[xml(rename = "Enabled", ns(""))]
        pub enabled: bool,
        /// The UUID of the speaker you want this alarm for
        #[xml(rename = "RoomUUID", ns(""))]
        pub room_uuid: String,
        /// The sound uri
        #[xml(rename = "ProgramURI", ns(""))]
        pub program_uri: String,
        /// The sound metadata, can be empty string
        #[xml(rename = "ProgramMetaData", ns(""))]
        pub program_meta_data: String,
        /// Alarm play mode
        #[xml(rename = "PlayMode", ns(""))]
        pub play_mode: super::AlarmPlayMode,
        /// Volume between 0 and 100
        #[xml(rename = "Volume", ns(""))]
        pub volume: u16,
        /// Should grouped players also play the alarm?
        #[xml(rename = "IncludeLinkedZones", ns(""))]
        pub include_linked_zones: bool,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "CreateAlarmResponse", ns(SERVICE_TYPE))]
    pub struct CreateAlarmResponse {
        #[xml(rename = "AssignedID", ns(""))]
        pub assigned_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for CreateAlarmResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "DestroyAlarm", ns(SERVICE_TYPE))]
    pub struct DestroyAlarmRequest {
        /// The Alarm ID from ListAlarms
        #[xml(rename = "ID", ns(""))]
        pub id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetDailyIndexRefreshTimeResponse", ns(SERVICE_TYPE))]
    pub struct GetDailyIndexRefreshTimeResponse {
        #[xml(rename = "CurrentDailyIndexRefreshTime", ns(""))]
        pub current_daily_index_refresh_time: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetDailyIndexRefreshTimeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetFormatResponse", ns(SERVICE_TYPE))]
    pub struct GetFormatResponse {
        #[xml(rename = "CurrentTimeFormat", ns(""))]
        pub current_time_format: Option<String>,
        #[xml(rename = "CurrentDateFormat", ns(""))]
        pub current_date_format: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetFormatResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetHouseholdTimeAtStamp", ns(SERVICE_TYPE))]
    pub struct GetHouseholdTimeAtStampRequest {
        #[xml(rename = "TimeStamp", ns(""))]
        pub time_stamp: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetHouseholdTimeAtStampResponse", ns(SERVICE_TYPE))]
    pub struct GetHouseholdTimeAtStampResponse {
        #[xml(rename = "HouseholdUTCTime", ns(""))]
        pub household_utc_time: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetHouseholdTimeAtStampResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTimeNowResponse", ns(SERVICE_TYPE))]
    pub struct GetTimeNowResponse {
        #[xml(rename = "CurrentUTCTime", ns(""))]
        pub current_utc_time: Option<String>,
        #[xml(rename = "CurrentLocalTime", ns(""))]
        pub current_local_time: Option<String>,
        #[xml(rename = "CurrentTimeZone", ns(""))]
        pub current_time_zone: Option<String>,
        #[xml(rename = "CurrentTimeGeneration", ns(""))]
        pub current_time_generation: Option<u32>,
    }

    impl crate::DecodeSoapResponse for GetTimeNowResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTimeServerResponse", ns(SERVICE_TYPE))]
    pub struct GetTimeServerResponse {
        #[xml(rename = "CurrentTimeServer", ns(""))]
        pub current_time_server: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetTimeServerResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTimeZoneResponse", ns(SERVICE_TYPE))]
    pub struct GetTimeZoneResponse {
        #[xml(rename = "Index", ns(""))]
        pub index: Option<i32>,
        #[xml(rename = "AutoAdjustDst", ns(""))]
        pub auto_adjust_dst: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetTimeZoneResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTimeZoneAndRuleResponse", ns(SERVICE_TYPE))]
    pub struct GetTimeZoneAndRuleResponse {
        #[xml(rename = "Index", ns(""))]
        pub index: Option<i32>,
        #[xml(rename = "AutoAdjustDst", ns(""))]
        pub auto_adjust_dst: Option<bool>,
        #[xml(rename = "CurrentTimeZone", ns(""))]
        pub current_time_zone: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetTimeZoneAndRuleResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetTimeZoneRule", ns(SERVICE_TYPE))]
    pub struct GetTimeZoneRuleRequest {
        #[xml(rename = "Index", ns(""))]
        pub index: i32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTimeZoneRuleResponse", ns(SERVICE_TYPE))]
    pub struct GetTimeZoneRuleResponse {
        #[xml(rename = "TimeZone", ns(""))]
        pub time_zone: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetTimeZoneRuleResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "ListAlarmsResponse", ns(SERVICE_TYPE))]
    pub struct ListAlarmsResponse {
        #[xml(rename = "CurrentAlarmList", ns(""))]
        pub current_alarm_list: Option<String>,
        #[xml(rename = "CurrentAlarmListVersion", ns(""))]
        pub current_alarm_list_version: Option<String>,
    }

    impl crate::DecodeSoapResponse for ListAlarmsResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetDailyIndexRefreshTime", ns(SERVICE_TYPE))]
    pub struct SetDailyIndexRefreshTimeRequest {
        #[xml(rename = "DesiredDailyIndexRefreshTime", ns(""))]
        pub desired_daily_index_refresh_time: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetFormat", ns(SERVICE_TYPE))]
    pub struct SetFormatRequest {
        #[xml(rename = "DesiredTimeFormat", ns(""))]
        pub desired_time_format: String,
        #[xml(rename = "DesiredDateFormat", ns(""))]
        pub desired_date_format: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetTimeNow", ns(SERVICE_TYPE))]
    pub struct SetTimeNowRequest {
        #[xml(rename = "DesiredTime", ns(""))]
        pub desired_time: String,
        #[xml(rename = "TimeZoneForDesiredTime", ns(""))]
        pub time_zone_for_desired_time: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetTimeServer", ns(SERVICE_TYPE))]
    pub struct SetTimeServerRequest {
        #[xml(rename = "DesiredTimeServer", ns(""))]
        pub desired_time_server: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetTimeZone", ns(SERVICE_TYPE))]
    pub struct SetTimeZoneRequest {
        #[xml(rename = "Index", ns(""))]
        pub index: i32,
        #[xml(rename = "AutoAdjustDst", ns(""))]
        pub auto_adjust_dst: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "UpdateAlarm", ns(SERVICE_TYPE))]
    pub struct UpdateAlarmRequest {
        /// The ID of the alarm see ListAlarms
        #[xml(rename = "ID", ns(""))]
        pub id: u32,
        /// The start time as `hh:mm:ss`
        #[xml(rename = "StartLocalTime", ns(""))]
        pub start_local_time: String,
        /// The duration as `hh:mm:ss`
        #[xml(rename = "Duration", ns(""))]
        pub duration: String,
        /// Repeat this alarm on
        #[xml(rename = "Recurrence", ns(""))]
        pub recurrence: super::Recurrence,
        /// Alarm enabled after creation
        #[xml(rename = "Enabled", ns(""))]
        pub enabled: bool,
        /// The UUID of the speaker you want this alarm for
        #[xml(rename = "RoomUUID", ns(""))]
        pub room_uuid: String,
        /// The sound uri
        #[xml(rename = "ProgramURI", ns(""))]
        pub program_uri: String,
        /// The sound metadata, can be empty string
        #[xml(rename = "ProgramMetaData", ns(""))]
        pub program_meta_data: String,
        /// Alarm play mode
        #[xml(rename = "PlayMode", ns(""))]
        pub play_mode: super::AlarmPlayMode,
        /// Volume between 0 and 100
        #[xml(rename = "Volume", ns(""))]
        pub volume: u16,
        /// Should grouped players also play the alarm?
        #[xml(rename = "IncludeLinkedZones", ns(""))]
        pub include_linked_zones: bool,
    }

    /// A parsed event produced by the `AlarmClock` service.
    /// Use `SonosDevice::subscribe_alarm_clock()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct AlarmClockEvent {
        pub alarm_list_version: Option<String>,
        pub daily_index_refresh_time: Option<String>,
        pub date_format: Option<String>,
        pub time_format: Option<String>,
        pub time_generation: Option<u32>,
        pub time_server: Option<String>,
        pub time_zone: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct AlarmClockPropertySet {
        pub properties: Vec<AlarmClockProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct AlarmClockProperty {
        #[xml(rename = "AlarmListVersion", ns(""))]
        pub alarm_list_version: Option<String>,
        #[xml(rename = "DailyIndexRefreshTime", ns(""))]
        pub daily_index_refresh_time: Option<String>,
        #[xml(rename = "DateFormat", ns(""))]
        pub date_format: Option<String>,
        #[xml(rename = "TimeFormat", ns(""))]
        pub time_format: Option<String>,
        #[xml(rename = "TimeGeneration", ns(""))]
        pub time_generation: Option<u32>,
        #[xml(rename = "TimeServer", ns(""))]
        pub time_server: Option<String>,
        #[xml(rename = "TimeZone", ns(""))]
        pub time_zone: Option<String>,
    }

    impl crate::upnp::DecodeXml for AlarmClockEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: AlarmClockPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.alarm_list_version {
                    result.alarm_list_version.replace(v);
                }

                if let Some(v) = prop.daily_index_refresh_time {
                    result.daily_index_refresh_time.replace(v);
                }

                if let Some(v) = prop.date_format {
                    result.date_format.replace(v);
                }

                if let Some(v) = prop.time_format {
                    result.time_format.replace(v);
                }

                if let Some(v) = prop.time_generation {
                    result.time_generation.replace(v);
                }

                if let Some(v) = prop.time_server {
                    result.time_server.replace(v);
                }

                if let Some(v) = prop.time_zone {
                    result.time_zone.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `AlarmClock` service on this device
        pub async fn subscribe_alarm_clock(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<AlarmClockEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum AlarmPlayMode {
    #[default]
    Normal,
    RepeatAll,
    ShuffleNorepeat,
    Shuffle,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for AlarmPlayMode {
    fn to_string(&self) -> String {
        match self {
            AlarmPlayMode::Normal => "NORMAL".to_string(),
            AlarmPlayMode::RepeatAll => "REPEAT_ALL".to_string(),
            AlarmPlayMode::ShuffleNorepeat => "SHUFFLE_NOREPEAT".to_string(),
            AlarmPlayMode::Shuffle => "SHUFFLE".to_string(),
            AlarmPlayMode::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for AlarmPlayMode {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<AlarmPlayMode> {
        match s {
            "NORMAL" => Ok(AlarmPlayMode::Normal),
            "REPEAT_ALL" => Ok(AlarmPlayMode::RepeatAll),
            "SHUFFLE_NOREPEAT" => Ok(AlarmPlayMode::ShuffleNorepeat),
            "SHUFFLE" => Ok(AlarmPlayMode::Shuffle),
            s => Ok(AlarmPlayMode::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for AlarmPlayMode {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for AlarmPlayMode {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: AlarmPlayMode = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<AlarmPlayMode>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum Recurrence {
    #[default]
    Once,
    Weekdays,
    Weekends,
    Daily,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for Recurrence {
    fn to_string(&self) -> String {
        match self {
            Recurrence::Once => "ONCE".to_string(),
            Recurrence::Weekdays => "WEEKDAYS".to_string(),
            Recurrence::Weekends => "WEEKENDS".to_string(),
            Recurrence::Daily => "DAILY".to_string(),
            Recurrence::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for Recurrence {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<Recurrence> {
        match s {
            "ONCE" => Ok(Recurrence::Once),
            "WEEKDAYS" => Ok(Recurrence::Weekdays),
            "WEEKENDS" => Ok(Recurrence::Weekends),
            "DAILY" => Ok(Recurrence::Daily),
            s => Ok(Recurrence::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for Recurrence {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for Recurrence {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: Recurrence = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<Recurrence>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

/// Request and Response types for the `AudioIn` service.
pub mod audio_in {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `AudioIn` service.
    /// `urn:schemas-upnp-org:service:AudioIn:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:AudioIn:1";

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetAudioInputAttributesResponse", ns(SERVICE_TYPE))]
    pub struct GetAudioInputAttributesResponse {
        #[xml(rename = "CurrentName", ns(""))]
        pub current_name: Option<String>,
        #[xml(rename = "CurrentIcon", ns(""))]
        pub current_icon: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetAudioInputAttributesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetLineInLevelResponse", ns(SERVICE_TYPE))]
    pub struct GetLineInLevelResponse {
        #[xml(rename = "CurrentLeftLineInLevel", ns(""))]
        pub current_left_line_in_level: Option<i32>,
        #[xml(rename = "CurrentRightLineInLevel", ns(""))]
        pub current_right_line_in_level: Option<i32>,
    }

    impl crate::DecodeSoapResponse for GetLineInLevelResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SelectAudio", ns(SERVICE_TYPE))]
    pub struct SelectAudioRequest {
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetAudioInputAttributes", ns(SERVICE_TYPE))]
    pub struct SetAudioInputAttributesRequest {
        #[xml(rename = "DesiredName", ns(""))]
        pub desired_name: String,
        #[xml(rename = "DesiredIcon", ns(""))]
        pub desired_icon: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetLineInLevel", ns(SERVICE_TYPE))]
    pub struct SetLineInLevelRequest {
        #[xml(rename = "DesiredLeftLineInLevel", ns(""))]
        pub desired_left_line_in_level: i32,
        #[xml(rename = "DesiredRightLineInLevel", ns(""))]
        pub desired_right_line_in_level: i32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "StartTransmissionToGroup", ns(SERVICE_TYPE))]
    pub struct StartTransmissionToGroupRequest {
        #[xml(rename = "CoordinatorID", ns(""))]
        pub coordinator_id: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "StartTransmissionToGroupResponse", ns(SERVICE_TYPE))]
    pub struct StartTransmissionToGroupResponse {
        #[xml(rename = "CurrentTransportSettings", ns(""))]
        pub current_transport_settings: Option<String>,
    }

    impl crate::DecodeSoapResponse for StartTransmissionToGroupResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "StopTransmissionToGroup", ns(SERVICE_TYPE))]
    pub struct StopTransmissionToGroupRequest {
        #[xml(rename = "CoordinatorID", ns(""))]
        pub coordinator_id: String,
    }

    /// A parsed event produced by the `AudioIn` service.
    /// Use `SonosDevice::subscribe_audio_in()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct AudioInEvent {
        pub audio_input_name: Option<String>,
        pub icon: Option<String>,
        pub left_line_in_level: Option<i32>,
        pub line_in_connected: Option<bool>,
        pub playing: Option<bool>,
        pub right_line_in_level: Option<i32>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct AudioInPropertySet {
        pub properties: Vec<AudioInProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct AudioInProperty {
        #[xml(rename = "AudioInputName", ns(""))]
        pub audio_input_name: Option<String>,
        #[xml(rename = "Icon", ns(""))]
        pub icon: Option<String>,
        #[xml(rename = "LeftLineInLevel", ns(""))]
        pub left_line_in_level: Option<i32>,
        #[xml(rename = "LineInConnected", ns(""))]
        pub line_in_connected: Option<bool>,
        #[xml(rename = "Playing", ns(""))]
        pub playing: Option<bool>,
        #[xml(rename = "RightLineInLevel", ns(""))]
        pub right_line_in_level: Option<i32>,
    }

    impl crate::upnp::DecodeXml for AudioInEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: AudioInPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.audio_input_name {
                    result.audio_input_name.replace(v);
                }

                if let Some(v) = prop.icon {
                    result.icon.replace(v);
                }

                if let Some(v) = prop.left_line_in_level {
                    result.left_line_in_level.replace(v);
                }

                if let Some(v) = prop.line_in_connected {
                    result.line_in_connected.replace(v);
                }

                if let Some(v) = prop.playing {
                    result.playing.replace(v);
                }

                if let Some(v) = prop.right_line_in_level {
                    result.right_line_in_level.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `AudioIn` service on this device
        pub async fn subscribe_audio_in(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<AudioInEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

/// Request and Response types for the `ConnectionManager` service.
pub mod connection_manager {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `ConnectionManager` service.
    /// `urn:schemas-upnp-org:service:ConnectionManager:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:ConnectionManager:1";

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetCurrentConnectionIDsResponse", ns(SERVICE_TYPE))]
    pub struct GetCurrentConnectionIdsResponse {
        #[xml(rename = "ConnectionIDs", ns(""))]
        pub connection_ids: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetCurrentConnectionIdsResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetCurrentConnectionInfo", ns(SERVICE_TYPE))]
    pub struct GetCurrentConnectionInfoRequest {
        #[xml(rename = "ConnectionID", ns(""))]
        pub connection_id: i32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetCurrentConnectionInfoResponse", ns(SERVICE_TYPE))]
    pub struct GetCurrentConnectionInfoResponse {
        #[xml(rename = "RcsID", ns(""))]
        pub rcs_id: Option<i32>,
        #[xml(rename = "AVTransportID", ns(""))]
        pub av_transport_id: Option<i32>,
        #[xml(rename = "ProtocolInfo", ns(""))]
        pub protocol_info: Option<String>,
        #[xml(rename = "PeerConnectionManager", ns(""))]
        pub peer_connection_manager: Option<String>,
        #[xml(rename = "PeerConnectionID", ns(""))]
        pub peer_connection_id: Option<i32>,
        #[xml(rename = "Direction", ns(""))]
        pub direction: Option<super::Direction>,
        #[xml(rename = "Status", ns(""))]
        pub status: Option<super::ConnectionStatus>,
    }

    impl crate::DecodeSoapResponse for GetCurrentConnectionInfoResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetProtocolInfoResponse", ns(SERVICE_TYPE))]
    pub struct GetProtocolInfoResponse {
        #[xml(rename = "Source", ns(""))]
        pub source: Option<String>,
        #[xml(rename = "Sink", ns(""))]
        pub sink: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetProtocolInfoResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    /// A parsed event produced by the `ConnectionManager` service.
    /// Use `SonosDevice::subscribe_connection_manager()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct ConnectionManagerEvent {
        pub current_connection_ids: Option<String>,
        pub sink_protocol_info: Option<String>,
        pub source_protocol_info: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct ConnectionManagerPropertySet {
        pub properties: Vec<ConnectionManagerProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct ConnectionManagerProperty {
        #[xml(rename = "CurrentConnectionIDs", ns(""))]
        pub current_connection_ids: Option<String>,
        #[xml(rename = "SinkProtocolInfo", ns(""))]
        pub sink_protocol_info: Option<String>,
        #[xml(rename = "SourceProtocolInfo", ns(""))]
        pub source_protocol_info: Option<String>,
    }

    impl crate::upnp::DecodeXml for ConnectionManagerEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: ConnectionManagerPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.current_connection_ids {
                    result.current_connection_ids.replace(v);
                }

                if let Some(v) = prop.sink_protocol_info {
                    result.sink_protocol_info.replace(v);
                }

                if let Some(v) = prop.source_protocol_info {
                    result.source_protocol_info.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `ConnectionManager` service on this device
        pub async fn subscribe_connection_manager(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<ConnectionManagerEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum ConnectionStatus {
    #[default]
    Ok,
    ContentFormatMismatch,
    InsufficientBandwidth,
    UnreliableChannel,
    Unknown,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for ConnectionStatus {
    fn to_string(&self) -> String {
        match self {
            ConnectionStatus::Ok => "OK".to_string(),
            ConnectionStatus::ContentFormatMismatch => "ContentFormatMismatch".to_string(),
            ConnectionStatus::InsufficientBandwidth => "InsufficientBandwidth".to_string(),
            ConnectionStatus::UnreliableChannel => "UnreliableChannel".to_string(),
            ConnectionStatus::Unknown => "Unknown".to_string(),
            ConnectionStatus::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for ConnectionStatus {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<ConnectionStatus> {
        match s {
            "OK" => Ok(ConnectionStatus::Ok),
            "ContentFormatMismatch" => Ok(ConnectionStatus::ContentFormatMismatch),
            "InsufficientBandwidth" => Ok(ConnectionStatus::InsufficientBandwidth),
            "UnreliableChannel" => Ok(ConnectionStatus::UnreliableChannel),
            "Unknown" => Ok(ConnectionStatus::Unknown),
            s => Ok(ConnectionStatus::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for ConnectionStatus {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for ConnectionStatus {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: ConnectionStatus = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<ConnectionStatus>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum Direction {
    #[default]
    Input,
    Output,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for Direction {
    fn to_string(&self) -> String {
        match self {
            Direction::Input => "Input".to_string(),
            Direction::Output => "Output".to_string(),
            Direction::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for Direction {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<Direction> {
        match s {
            "Input" => Ok(Direction::Input),
            "Output" => Ok(Direction::Output),
            s => Ok(Direction::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for Direction {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for Direction {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: Direction = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<Direction>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

/// Request and Response types for the `ContentDirectory` service.
pub mod content_directory {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `ContentDirectory` service.
    /// `urn:schemas-upnp-org:service:ContentDirectory:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:ContentDirectory:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Browse", ns(SERVICE_TYPE))]
    pub struct BrowseRequest {
        /// The search query, (`A:ARTIST` / `A:ALBUMARTIST` / `A:ALBUM` / `A:GENRE` / `A:COMPOSER` / `A:TRACKS` / `A:PLAYLISTS` / `FV:2` / `Q:`/ `R:0/0` / `R:0/1` / `S:` / `SQ:`) with optionally `:search+query` behind it.
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
        /// How to browse
        #[xml(rename = "BrowseFlag", ns(""))]
        pub browse_flag: super::BrowseFlag,
        /// Which fields should be returned `*` for all.
        #[xml(rename = "Filter", ns(""))]
        pub filter: String,
        /// Paging, where to start, usually 0
        #[xml(rename = "StartingIndex", ns(""))]
        pub starting_index: u32,
        /// Paging, number of items, maximum is 1,000. This parameter does NOT restrict the number of items being searched (filter) but only the number being returned. Using 0 is equivalent to 1,000
        #[xml(rename = "RequestedCount", ns(""))]
        pub requested_count: u32,
        /// Sort the results based on metadata fields. `+upnp:artist,+dc:title` for sorting on artist then on title.
        #[xml(rename = "SortCriteria", ns(""))]
        pub sort_criteria: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "BrowseResponse", ns(SERVICE_TYPE))]
    pub struct BrowseResponse {
        #[xml(rename = "Result", ns(""))]
        pub result: Option<crate::xmlutil::DecodeXmlString<crate::TrackMetaDataList>>,
        #[xml(rename = "NumberReturned", ns(""))]
        pub number_returned: Option<u32>,
        #[xml(rename = "TotalMatches", ns(""))]
        pub total_matches: Option<u32>,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for BrowseResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "CreateObject", ns(SERVICE_TYPE))]
    pub struct CreateObjectRequest {
        #[xml(rename = "ContainerID", ns(""))]
        pub container_id: String,
        #[xml(rename = "Elements", ns(""))]
        pub elements: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "CreateObjectResponse", ns(SERVICE_TYPE))]
    pub struct CreateObjectResponse {
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: Option<String>,
        #[xml(rename = "Result", ns(""))]
        pub result: Option<String>,
    }

    impl crate::DecodeSoapResponse for CreateObjectResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "DestroyObject", ns(SERVICE_TYPE))]
    pub struct DestroyObjectRequest {
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "FindPrefix", ns(SERVICE_TYPE))]
    pub struct FindPrefixRequest {
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
        #[xml(rename = "Prefix", ns(""))]
        pub prefix: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "FindPrefixResponse", ns(SERVICE_TYPE))]
    pub struct FindPrefixResponse {
        #[xml(rename = "StartingIndex", ns(""))]
        pub starting_index: Option<u32>,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for FindPrefixResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetAlbumArtistDisplayOptionResponse", ns(SERVICE_TYPE))]
    pub struct GetAlbumArtistDisplayOptionResponse {
        #[xml(rename = "AlbumArtistDisplayOption", ns(""))]
        pub album_artist_display_option: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetAlbumArtistDisplayOptionResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetAllPrefixLocations", ns(SERVICE_TYPE))]
    pub struct GetAllPrefixLocationsRequest {
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetAllPrefixLocationsResponse", ns(SERVICE_TYPE))]
    pub struct GetAllPrefixLocationsResponse {
        #[xml(rename = "TotalPrefixes", ns(""))]
        pub total_prefixes: Option<u32>,
        #[xml(rename = "PrefixAndIndexCSV", ns(""))]
        pub prefix_and_index_csv: Option<String>,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for GetAllPrefixLocationsResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetBrowseableResponse", ns(SERVICE_TYPE))]
    pub struct GetBrowseableResponse {
        #[xml(rename = "IsBrowseable", ns(""))]
        pub is_browseable: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetBrowseableResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetLastIndexChangeResponse", ns(SERVICE_TYPE))]
    pub struct GetLastIndexChangeResponse {
        #[xml(rename = "LastIndexChange", ns(""))]
        pub last_index_change: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetLastIndexChangeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetSearchCapabilitiesResponse", ns(SERVICE_TYPE))]
    pub struct GetSearchCapabilitiesResponse {
        #[xml(rename = "SearchCaps", ns(""))]
        pub search_caps: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetSearchCapabilitiesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetShareIndexInProgressResponse", ns(SERVICE_TYPE))]
    pub struct GetShareIndexInProgressResponse {
        #[xml(rename = "IsIndexing", ns(""))]
        pub is_indexing: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetShareIndexInProgressResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetSortCapabilitiesResponse", ns(SERVICE_TYPE))]
    pub struct GetSortCapabilitiesResponse {
        #[xml(rename = "SortCaps", ns(""))]
        pub sort_caps: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetSortCapabilitiesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetSystemUpdateIDResponse", ns(SERVICE_TYPE))]
    pub struct GetSystemUpdateIdResponse {
        #[xml(rename = "Id", ns(""))]
        pub id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for GetSystemUpdateIdResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RefreshShareIndex", ns(SERVICE_TYPE))]
    pub struct RefreshShareIndexRequest {
        /// `WMP`, `ITUNES` or `NONE`
        #[xml(rename = "AlbumArtistDisplayOption", ns(""))]
        pub album_artist_display_option: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RequestResort", ns(SERVICE_TYPE))]
    pub struct RequestResortRequest {
        #[xml(rename = "SortOrder", ns(""))]
        pub sort_order: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetBrowseable", ns(SERVICE_TYPE))]
    pub struct SetBrowseableRequest {
        #[xml(rename = "Browseable", ns(""))]
        pub browseable: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "UpdateObject", ns(SERVICE_TYPE))]
    pub struct UpdateObjectRequest {
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
        #[xml(rename = "CurrentTagValue", ns(""))]
        pub current_tag_value: String,
        #[xml(rename = "NewTagValue", ns(""))]
        pub new_tag_value: String,
    }

    /// A parsed event produced by the `ContentDirectory` service.
    /// Use `SonosDevice::subscribe_content_directory()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct ContentDirectoryEvent {
        pub browseable: Option<bool>,
        pub container_update_ids: Option<String>,
        pub favorite_presets_update_id: Option<String>,
        pub favorites_update_id: Option<String>,
        pub radio_favorites_update_id: Option<u32>,
        pub radio_location_update_id: Option<u32>,
        pub recently_played_update_id: Option<String>,
        pub saved_queues_update_id: Option<String>,
        pub share_index_in_progress: Option<bool>,
        pub share_index_last_error: Option<String>,
        pub share_list_update_id: Option<String>,
        pub system_update_id: Option<u32>,
        pub user_radio_update_id: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct ContentDirectoryPropertySet {
        pub properties: Vec<ContentDirectoryProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct ContentDirectoryProperty {
        #[xml(rename = "Browseable", ns(""))]
        pub browseable: Option<bool>,
        #[xml(rename = "ContainerUpdateIDs", ns(""))]
        pub container_update_ids: Option<String>,
        #[xml(rename = "FavoritePresetsUpdateID", ns(""))]
        pub favorite_presets_update_id: Option<String>,
        #[xml(rename = "FavoritesUpdateID", ns(""))]
        pub favorites_update_id: Option<String>,
        #[xml(rename = "RadioFavoritesUpdateID", ns(""))]
        pub radio_favorites_update_id: Option<u32>,
        #[xml(rename = "RadioLocationUpdateID", ns(""))]
        pub radio_location_update_id: Option<u32>,
        #[xml(rename = "RecentlyPlayedUpdateID", ns(""))]
        pub recently_played_update_id: Option<String>,
        #[xml(rename = "SavedQueuesUpdateID", ns(""))]
        pub saved_queues_update_id: Option<String>,
        #[xml(rename = "ShareIndexInProgress", ns(""))]
        pub share_index_in_progress: Option<bool>,
        #[xml(rename = "ShareIndexLastError", ns(""))]
        pub share_index_last_error: Option<String>,
        #[xml(rename = "ShareListUpdateID", ns(""))]
        pub share_list_update_id: Option<String>,
        #[xml(rename = "SystemUpdateID", ns(""))]
        pub system_update_id: Option<u32>,
        #[xml(rename = "UserRadioUpdateID", ns(""))]
        pub user_radio_update_id: Option<String>,
    }

    impl crate::upnp::DecodeXml for ContentDirectoryEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: ContentDirectoryPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.browseable {
                    result.browseable.replace(v);
                }

                if let Some(v) = prop.container_update_ids {
                    result.container_update_ids.replace(v);
                }

                if let Some(v) = prop.favorite_presets_update_id {
                    result.favorite_presets_update_id.replace(v);
                }

                if let Some(v) = prop.favorites_update_id {
                    result.favorites_update_id.replace(v);
                }

                if let Some(v) = prop.radio_favorites_update_id {
                    result.radio_favorites_update_id.replace(v);
                }

                if let Some(v) = prop.radio_location_update_id {
                    result.radio_location_update_id.replace(v);
                }

                if let Some(v) = prop.recently_played_update_id {
                    result.recently_played_update_id.replace(v);
                }

                if let Some(v) = prop.saved_queues_update_id {
                    result.saved_queues_update_id.replace(v);
                }

                if let Some(v) = prop.share_index_in_progress {
                    result.share_index_in_progress.replace(v);
                }

                if let Some(v) = prop.share_index_last_error {
                    result.share_index_last_error.replace(v);
                }

                if let Some(v) = prop.share_list_update_id {
                    result.share_list_update_id.replace(v);
                }

                if let Some(v) = prop.system_update_id {
                    result.system_update_id.replace(v);
                }

                if let Some(v) = prop.user_radio_update_id {
                    result.user_radio_update_id.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `ContentDirectory` service on this device
        pub async fn subscribe_content_directory(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<ContentDirectoryEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum BrowseFlag {
    #[default]
    BrowseMetadata,
    BrowseDirectChildren,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for BrowseFlag {
    fn to_string(&self) -> String {
        match self {
            BrowseFlag::BrowseMetadata => "BrowseMetadata".to_string(),
            BrowseFlag::BrowseDirectChildren => "BrowseDirectChildren".to_string(),
            BrowseFlag::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for BrowseFlag {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<BrowseFlag> {
        match s {
            "BrowseMetadata" => Ok(BrowseFlag::BrowseMetadata),
            "BrowseDirectChildren" => Ok(BrowseFlag::BrowseDirectChildren),
            s => Ok(BrowseFlag::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for BrowseFlag {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for BrowseFlag {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: BrowseFlag = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<BrowseFlag>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

/// Request and Response types for the `DeviceProperties` service.
pub mod device_properties {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `DeviceProperties` service.
    /// `urn:schemas-upnp-org:service:DeviceProperties:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:DeviceProperties:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddBondedZones", ns(SERVICE_TYPE))]
    pub struct AddBondedZonesRequest {
        #[xml(rename = "ChannelMapSet", ns(""))]
        pub channel_map_set: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddHTSatellite", ns(SERVICE_TYPE))]
    pub struct AddHtSatelliteRequest {
        /// example: `RINCON_000PPP1400:LF,RF;RINCON_000RRR1400:RR;RINCON_000SSS1400:LR;RINCON_000QQQ1400:SW`
        #[xml(rename = "HTSatChanMapSet", ns(""))]
        pub ht_sat_chan_map_set: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "CreateStereoPair", ns(SERVICE_TYPE))]
    pub struct CreateStereoPairRequest {
        /// example: `RINCON_B8E9375831C001400:LF,LF;RINCON_000E58FE3AEA01400:RF,RF`
        #[xml(rename = "ChannelMapSet", ns(""))]
        pub channel_map_set: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "EnterConfigMode", ns(SERVICE_TYPE))]
    pub struct EnterConfigModeRequest {
        #[xml(rename = "Mode", ns(""))]
        pub mode: String,
        #[xml(rename = "Options", ns(""))]
        pub options: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "EnterConfigModeResponse", ns(SERVICE_TYPE))]
    pub struct EnterConfigModeResponse {
        #[xml(rename = "State", ns(""))]
        pub state: Option<String>,
    }

    impl crate::DecodeSoapResponse for EnterConfigModeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ExitConfigMode", ns(SERVICE_TYPE))]
    pub struct ExitConfigModeRequest {
        #[xml(rename = "Options", ns(""))]
        pub options: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetAutoplayLinkedZones", ns(SERVICE_TYPE))]
    pub struct GetAutoplayLinkedZonesRequest {
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetAutoplayLinkedZonesResponse", ns(SERVICE_TYPE))]
    pub struct GetAutoplayLinkedZonesResponse {
        #[xml(rename = "IncludeLinkedZones", ns(""))]
        pub include_linked_zones: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetAutoplayLinkedZonesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetAutoplayRoomUUID", ns(SERVICE_TYPE))]
    pub struct GetAutoplayRoomUuidRequest {
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetAutoplayRoomUUIDResponse", ns(SERVICE_TYPE))]
    pub struct GetAutoplayRoomUuidResponse {
        #[xml(rename = "RoomUUID", ns(""))]
        pub room_uuid: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetAutoplayRoomUuidResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetAutoplayVolume", ns(SERVICE_TYPE))]
    pub struct GetAutoplayVolumeRequest {
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetAutoplayVolumeResponse", ns(SERVICE_TYPE))]
    pub struct GetAutoplayVolumeResponse {
        #[xml(rename = "CurrentVolume", ns(""))]
        pub current_volume: Option<u16>,
    }

    impl crate::DecodeSoapResponse for GetAutoplayVolumeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetButtonLockStateResponse", ns(SERVICE_TYPE))]
    pub struct GetButtonLockStateResponse {
        #[xml(rename = "CurrentButtonLockState", ns(""))]
        pub current_button_lock_state: Option<super::ButtonLockState>,
    }

    impl crate::DecodeSoapResponse for GetButtonLockStateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetButtonStateResponse", ns(SERVICE_TYPE))]
    pub struct GetButtonStateResponse {
        #[xml(rename = "State", ns(""))]
        pub state: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetButtonStateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetHTForwardStateResponse", ns(SERVICE_TYPE))]
    pub struct GetHtForwardStateResponse {
        #[xml(rename = "IsHTForwardEnabled", ns(""))]
        pub is_ht_forward_enabled: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetHtForwardStateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetHouseholdIDResponse", ns(SERVICE_TYPE))]
    pub struct GetHouseholdIdResponse {
        #[xml(rename = "CurrentHouseholdID", ns(""))]
        pub current_household_id: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetHouseholdIdResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetLEDStateResponse", ns(SERVICE_TYPE))]
    pub struct GetLedStateResponse {
        #[xml(rename = "CurrentLEDState", ns(""))]
        pub current_led_state: Option<super::LEDState>,
    }

    impl crate::DecodeSoapResponse for GetLedStateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetUseAutoplayVolume", ns(SERVICE_TYPE))]
    pub struct GetUseAutoplayVolumeRequest {
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetUseAutoplayVolumeResponse", ns(SERVICE_TYPE))]
    pub struct GetUseAutoplayVolumeResponse {
        #[xml(rename = "UseVolume", ns(""))]
        pub use_volume: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetUseAutoplayVolumeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetZoneAttributesResponse", ns(SERVICE_TYPE))]
    pub struct GetZoneAttributesResponse {
        #[xml(rename = "CurrentZoneName", ns(""))]
        pub current_zone_name: Option<String>,
        #[xml(rename = "CurrentIcon", ns(""))]
        pub current_icon: Option<String>,
        #[xml(rename = "CurrentConfiguration", ns(""))]
        pub current_configuration: Option<String>,
        #[xml(rename = "CurrentTargetRoomName", ns(""))]
        pub current_target_room_name: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetZoneAttributesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetZoneInfoResponse", ns(SERVICE_TYPE))]
    pub struct GetZoneInfoResponse {
        #[xml(rename = "SerialNumber", ns(""))]
        pub serial_number: Option<String>,
        #[xml(rename = "SoftwareVersion", ns(""))]
        pub software_version: Option<String>,
        #[xml(rename = "DisplaySoftwareVersion", ns(""))]
        pub display_software_version: Option<String>,
        #[xml(rename = "HardwareVersion", ns(""))]
        pub hardware_version: Option<String>,
        #[xml(rename = "IPAddress", ns(""))]
        pub ip_address: Option<String>,
        #[xml(rename = "MACAddress", ns(""))]
        pub mac_address: Option<String>,
        #[xml(rename = "CopyrightInfo", ns(""))]
        pub copyright_info: Option<String>,
        #[xml(rename = "ExtraInfo", ns(""))]
        pub extra_info: Option<String>,
        #[xml(rename = "HTAudioIn", ns(""))]
        pub ht_audio_in: Option<u32>,
        #[xml(rename = "Flags", ns(""))]
        pub flags: Option<u32>,
    }

    impl crate::DecodeSoapResponse for GetZoneInfoResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveBondedZones", ns(SERVICE_TYPE))]
    pub struct RemoveBondedZonesRequest {
        #[xml(rename = "ChannelMapSet", ns(""))]
        pub channel_map_set: String,
        #[xml(rename = "KeepGrouped", ns(""))]
        pub keep_grouped: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveHTSatellite", ns(SERVICE_TYPE))]
    pub struct RemoveHtSatelliteRequest {
        /// example: `RINCON_000RRR1400`
        #[xml(rename = "SatRoomUUID", ns(""))]
        pub sat_room_uuid: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RoomDetectionStartChirping", ns(SERVICE_TYPE))]
    pub struct RoomDetectionStartChirpingRequest {
        #[xml(rename = "Channel", ns(""))]
        pub channel: u16,
        #[xml(rename = "DurationMilliseconds", ns(""))]
        pub duration_milliseconds: u32,
        #[xml(rename = "ChirpIfPlayingSwappableAudio", ns(""))]
        pub chirp_if_playing_swappable_audio: bool,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "RoomDetectionStartChirpingResponse", ns(SERVICE_TYPE))]
    pub struct RoomDetectionStartChirpingResponse {
        #[xml(rename = "PlayId", ns(""))]
        pub play_id: Option<u32>,
        #[xml(rename = "ChirpIfPlayingSwappableAudio", ns(""))]
        pub chirp_if_playing_swappable_audio: Option<bool>,
    }

    impl crate::DecodeSoapResponse for RoomDetectionStartChirpingResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RoomDetectionStopChirping", ns(SERVICE_TYPE))]
    pub struct RoomDetectionStopChirpingRequest {
        #[xml(rename = "PlayId", ns(""))]
        pub play_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SeparateStereoPair", ns(SERVICE_TYPE))]
    pub struct SeparateStereoPairRequest {
        /// example: `RINCON_B8E9375831C001400:LF,LF;RINCON_000E58FE3AEA01400:RF,RF`
        #[xml(rename = "ChannelMapSet", ns(""))]
        pub channel_map_set: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetAutoplayLinkedZones", ns(SERVICE_TYPE))]
    pub struct SetAutoplayLinkedZonesRequest {
        #[xml(rename = "IncludeLinkedZones", ns(""))]
        pub include_linked_zones: bool,
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetAutoplayRoomUUID", ns(SERVICE_TYPE))]
    pub struct SetAutoplayRoomUuidRequest {
        #[xml(rename = "RoomUUID", ns(""))]
        pub room_uuid: String,
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetAutoplayVolume", ns(SERVICE_TYPE))]
    pub struct SetAutoplayVolumeRequest {
        #[xml(rename = "Volume", ns(""))]
        pub volume: u16,
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetButtonLockState", ns(SERVICE_TYPE))]
    pub struct SetButtonLockStateRequest {
        #[xml(rename = "DesiredButtonLockState", ns(""))]
        pub desired_button_lock_state: super::ButtonLockState,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetLEDState", ns(SERVICE_TYPE))]
    pub struct SetLedStateRequest {
        #[xml(rename = "DesiredLEDState", ns(""))]
        pub desired_led_state: super::LEDState,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetUseAutoplayVolume", ns(SERVICE_TYPE))]
    pub struct SetUseAutoplayVolumeRequest {
        #[xml(rename = "UseVolume", ns(""))]
        pub use_volume: bool,
        #[xml(rename = "Source", ns(""))]
        pub source: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetZoneAttributes", ns(SERVICE_TYPE))]
    pub struct SetZoneAttributesRequest {
        #[xml(rename = "DesiredZoneName", ns(""))]
        pub desired_zone_name: String,
        #[xml(rename = "DesiredIcon", ns(""))]
        pub desired_icon: String,
        #[xml(rename = "DesiredConfiguration", ns(""))]
        pub desired_configuration: String,
        #[xml(rename = "DesiredTargetRoomName", ns(""))]
        pub desired_target_room_name: String,
    }

    /// A parsed event produced by the `DeviceProperties` service.
    /// Use `SonosDevice::subscribe_device_properties()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct DevicePropertiesEvent {
        pub air_play_enabled: Option<bool>,
        pub available_room_calibration: Option<String>,
        pub behind_wifi_extender: Option<u32>,
        pub channel_freq: Option<u32>,
        pub channel_map_set: Option<String>,
        pub config_mode: Option<String>,
        pub configuration: Option<String>,
        pub eth_link: Option<bool>,
        pub ht_bonded_zone_commit_state: Option<u32>,
        pub ht_freq: Option<u32>,
        pub ht_sat_chan_map_set: Option<String>,
        pub has_configured_ssid: Option<bool>,
        pub hdmi_cec_available: Option<bool>,
        pub icon: Option<String>,
        pub invisible: Option<bool>,
        pub is_idle: Option<bool>,
        pub is_zone_bridge: Option<bool>,
        pub last_changed_play_state: Option<String>,
        pub mic_enabled: Option<u32>,
        pub more_info: Option<String>,
        pub orientation: Option<i32>,
        pub room_calibration_state: Option<i32>,
        pub secure_reg_state: Option<u32>,
        pub settings_replication_state: Option<String>,
        pub supports_audio_clip: Option<bool>,
        pub supports_audio_in: Option<bool>,
        pub tv_configuration_error: Option<bool>,
        pub voice_config_state: Option<u32>,
        pub wifi_enabled: Option<bool>,
        pub wireless_leaf_only: Option<bool>,
        pub wireless_mode: Option<u32>,
        pub zone_name: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct DevicePropertiesPropertySet {
        pub properties: Vec<DevicePropertiesProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct DevicePropertiesProperty {
        #[xml(rename = "AirPlayEnabled", ns(""))]
        pub air_play_enabled: Option<bool>,
        #[xml(rename = "AvailableRoomCalibration", ns(""))]
        pub available_room_calibration: Option<String>,
        #[xml(rename = "BehindWifiExtender", ns(""))]
        pub behind_wifi_extender: Option<u32>,
        #[xml(rename = "ChannelFreq", ns(""))]
        pub channel_freq: Option<u32>,
        #[xml(rename = "ChannelMapSet", ns(""))]
        pub channel_map_set: Option<String>,
        #[xml(rename = "ConfigMode", ns(""))]
        pub config_mode: Option<String>,
        #[xml(rename = "Configuration", ns(""))]
        pub configuration: Option<String>,
        #[xml(rename = "EthLink", ns(""))]
        pub eth_link: Option<bool>,
        #[xml(rename = "HTBondedZoneCommitState", ns(""))]
        pub ht_bonded_zone_commit_state: Option<u32>,
        #[xml(rename = "HTFreq", ns(""))]
        pub ht_freq: Option<u32>,
        #[xml(rename = "HTSatChanMapSet", ns(""))]
        pub ht_sat_chan_map_set: Option<String>,
        #[xml(rename = "HasConfiguredSSID", ns(""))]
        pub has_configured_ssid: Option<bool>,
        #[xml(rename = "HdmiCecAvailable", ns(""))]
        pub hdmi_cec_available: Option<bool>,
        #[xml(rename = "Icon", ns(""))]
        pub icon: Option<String>,
        #[xml(rename = "Invisible", ns(""))]
        pub invisible: Option<bool>,
        #[xml(rename = "IsIdle", ns(""))]
        pub is_idle: Option<bool>,
        #[xml(rename = "IsZoneBridge", ns(""))]
        pub is_zone_bridge: Option<bool>,
        #[xml(rename = "LastChangedPlayState", ns(""))]
        pub last_changed_play_state: Option<String>,
        #[xml(rename = "MicEnabled", ns(""))]
        pub mic_enabled: Option<u32>,
        #[xml(rename = "MoreInfo", ns(""))]
        pub more_info: Option<String>,
        #[xml(rename = "Orientation", ns(""))]
        pub orientation: Option<i32>,
        #[xml(rename = "RoomCalibrationState", ns(""))]
        pub room_calibration_state: Option<i32>,
        #[xml(rename = "SecureRegState", ns(""))]
        pub secure_reg_state: Option<u32>,
        #[xml(rename = "SettingsReplicationState", ns(""))]
        pub settings_replication_state: Option<String>,
        #[xml(rename = "SupportsAudioClip", ns(""))]
        pub supports_audio_clip: Option<bool>,
        #[xml(rename = "SupportsAudioIn", ns(""))]
        pub supports_audio_in: Option<bool>,
        #[xml(rename = "TVConfigurationError", ns(""))]
        pub tv_configuration_error: Option<bool>,
        #[xml(rename = "VoiceConfigState", ns(""))]
        pub voice_config_state: Option<u32>,
        #[xml(rename = "WifiEnabled", ns(""))]
        pub wifi_enabled: Option<bool>,
        #[xml(rename = "WirelessLeafOnly", ns(""))]
        pub wireless_leaf_only: Option<bool>,
        #[xml(rename = "WirelessMode", ns(""))]
        pub wireless_mode: Option<u32>,
        #[xml(rename = "ZoneName", ns(""))]
        pub zone_name: Option<String>,
    }

    impl crate::upnp::DecodeXml for DevicePropertiesEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: DevicePropertiesPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.air_play_enabled {
                    result.air_play_enabled.replace(v);
                }

                if let Some(v) = prop.available_room_calibration {
                    result.available_room_calibration.replace(v);
                }

                if let Some(v) = prop.behind_wifi_extender {
                    result.behind_wifi_extender.replace(v);
                }

                if let Some(v) = prop.channel_freq {
                    result.channel_freq.replace(v);
                }

                if let Some(v) = prop.channel_map_set {
                    result.channel_map_set.replace(v);
                }

                if let Some(v) = prop.config_mode {
                    result.config_mode.replace(v);
                }

                if let Some(v) = prop.configuration {
                    result.configuration.replace(v);
                }

                if let Some(v) = prop.eth_link {
                    result.eth_link.replace(v);
                }

                if let Some(v) = prop.ht_bonded_zone_commit_state {
                    result.ht_bonded_zone_commit_state.replace(v);
                }

                if let Some(v) = prop.ht_freq {
                    result.ht_freq.replace(v);
                }

                if let Some(v) = prop.ht_sat_chan_map_set {
                    result.ht_sat_chan_map_set.replace(v);
                }

                if let Some(v) = prop.has_configured_ssid {
                    result.has_configured_ssid.replace(v);
                }

                if let Some(v) = prop.hdmi_cec_available {
                    result.hdmi_cec_available.replace(v);
                }

                if let Some(v) = prop.icon {
                    result.icon.replace(v);
                }

                if let Some(v) = prop.invisible {
                    result.invisible.replace(v);
                }

                if let Some(v) = prop.is_idle {
                    result.is_idle.replace(v);
                }

                if let Some(v) = prop.is_zone_bridge {
                    result.is_zone_bridge.replace(v);
                }

                if let Some(v) = prop.last_changed_play_state {
                    result.last_changed_play_state.replace(v);
                }

                if let Some(v) = prop.mic_enabled {
                    result.mic_enabled.replace(v);
                }

                if let Some(v) = prop.more_info {
                    result.more_info.replace(v);
                }

                if let Some(v) = prop.orientation {
                    result.orientation.replace(v);
                }

                if let Some(v) = prop.room_calibration_state {
                    result.room_calibration_state.replace(v);
                }

                if let Some(v) = prop.secure_reg_state {
                    result.secure_reg_state.replace(v);
                }

                if let Some(v) = prop.settings_replication_state {
                    result.settings_replication_state.replace(v);
                }

                if let Some(v) = prop.supports_audio_clip {
                    result.supports_audio_clip.replace(v);
                }

                if let Some(v) = prop.supports_audio_in {
                    result.supports_audio_in.replace(v);
                }

                if let Some(v) = prop.tv_configuration_error {
                    result.tv_configuration_error.replace(v);
                }

                if let Some(v) = prop.voice_config_state {
                    result.voice_config_state.replace(v);
                }

                if let Some(v) = prop.wifi_enabled {
                    result.wifi_enabled.replace(v);
                }

                if let Some(v) = prop.wireless_leaf_only {
                    result.wireless_leaf_only.replace(v);
                }

                if let Some(v) = prop.wireless_mode {
                    result.wireless_mode.replace(v);
                }

                if let Some(v) = prop.zone_name {
                    result.zone_name.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `DeviceProperties` service on this device
        pub async fn subscribe_device_properties(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<DevicePropertiesEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum ButtonLockState {
    #[default]
    On,
    Off,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for ButtonLockState {
    fn to_string(&self) -> String {
        match self {
            ButtonLockState::On => "On".to_string(),
            ButtonLockState::Off => "Off".to_string(),
            ButtonLockState::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for ButtonLockState {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<ButtonLockState> {
        match s {
            "On" => Ok(ButtonLockState::On),
            "Off" => Ok(ButtonLockState::Off),
            s => Ok(ButtonLockState::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for ButtonLockState {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for ButtonLockState {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: ButtonLockState = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<ButtonLockState>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum LEDState {
    #[default]
    On,
    Off,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for LEDState {
    fn to_string(&self) -> String {
        match self {
            LEDState::On => "On".to_string(),
            LEDState::Off => "Off".to_string(),
            LEDState::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for LEDState {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<LEDState> {
        match s {
            "On" => Ok(LEDState::On),
            "Off" => Ok(LEDState::Off),
            s => Ok(LEDState::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for LEDState {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for LEDState {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: LEDState = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<LEDState>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

/// Request and Response types for the `GroupManagement` service.
pub mod group_management {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `GroupManagement` service.
    /// `urn:schemas-upnp-org:service:GroupManagement:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:GroupManagement:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddMember", ns(SERVICE_TYPE))]
    pub struct AddMemberRequest {
        #[xml(rename = "MemberID", ns(""))]
        pub member_id: String,
        #[xml(rename = "BootSeq", ns(""))]
        pub boot_seq: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddMemberResponse", ns(SERVICE_TYPE))]
    pub struct AddMemberResponse {
        #[xml(rename = "CurrentTransportSettings", ns(""))]
        pub current_transport_settings: Option<String>,
        #[xml(rename = "CurrentURI", ns(""))]
        pub current_uri: Option<String>,
        #[xml(rename = "GroupUUIDJoined", ns(""))]
        pub group_uuid_joined: Option<String>,
        #[xml(rename = "ResetVolumeAfter", ns(""))]
        pub reset_volume_after: Option<bool>,
        #[xml(rename = "VolumeAVTransportURI", ns(""))]
        pub volume_av_transport_uri: Option<String>,
    }

    impl crate::DecodeSoapResponse for AddMemberResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveMember", ns(SERVICE_TYPE))]
    pub struct RemoveMemberRequest {
        #[xml(rename = "MemberID", ns(""))]
        pub member_id: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ReportTrackBufferingResult", ns(SERVICE_TYPE))]
    pub struct ReportTrackBufferingResultRequest {
        #[xml(rename = "MemberID", ns(""))]
        pub member_id: String,
        #[xml(rename = "ResultCode", ns(""))]
        pub result_code: i32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetSourceAreaIds", ns(SERVICE_TYPE))]
    pub struct SetSourceAreaIdsRequest {
        #[xml(rename = "DesiredSourceAreaIds", ns(""))]
        pub desired_source_area_ids: String,
    }

    /// A parsed event produced by the `GroupManagement` service.
    /// Use `SonosDevice::subscribe_group_management()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct GroupManagementEvent {
        pub group_coordinator_is_local: Option<bool>,
        pub local_group_uuid: Option<String>,
        pub reset_volume_after: Option<bool>,
        pub virtual_line_in_group_id: Option<String>,
        pub volume_av_transport_uri: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct GroupManagementPropertySet {
        pub properties: Vec<GroupManagementProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct GroupManagementProperty {
        #[xml(rename = "GroupCoordinatorIsLocal", ns(""))]
        pub group_coordinator_is_local: Option<bool>,
        #[xml(rename = "LocalGroupUUID", ns(""))]
        pub local_group_uuid: Option<String>,
        #[xml(rename = "ResetVolumeAfter", ns(""))]
        pub reset_volume_after: Option<bool>,
        #[xml(rename = "VirtualLineInGroupID", ns(""))]
        pub virtual_line_in_group_id: Option<String>,
        #[xml(rename = "VolumeAVTransportURI", ns(""))]
        pub volume_av_transport_uri: Option<String>,
    }

    impl crate::upnp::DecodeXml for GroupManagementEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: GroupManagementPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.group_coordinator_is_local {
                    result.group_coordinator_is_local.replace(v);
                }

                if let Some(v) = prop.local_group_uuid {
                    result.local_group_uuid.replace(v);
                }

                if let Some(v) = prop.reset_volume_after {
                    result.reset_volume_after.replace(v);
                }

                if let Some(v) = prop.virtual_line_in_group_id {
                    result.virtual_line_in_group_id.replace(v);
                }

                if let Some(v) = prop.volume_av_transport_uri {
                    result.volume_av_transport_uri.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `GroupManagement` service on this device
        pub async fn subscribe_group_management(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<GroupManagementEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

/// Request and Response types for the `GroupRenderingControl` service.
pub mod group_rendering_control {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `GroupRenderingControl` service.
    /// `urn:schemas-upnp-org:service:GroupRenderingControl:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:GroupRenderingControl:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetGroupMute", ns(SERVICE_TYPE))]
    pub struct GetGroupMuteRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetGroupMuteResponse", ns(SERVICE_TYPE))]
    pub struct GetGroupMuteResponse {
        #[xml(rename = "CurrentMute", ns(""))]
        pub current_mute: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetGroupMuteResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetGroupVolume", ns(SERVICE_TYPE))]
    pub struct GetGroupVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetGroupVolumeResponse", ns(SERVICE_TYPE))]
    pub struct GetGroupVolumeResponse {
        #[xml(rename = "CurrentVolume", ns(""))]
        pub current_volume: Option<u16>,
    }

    impl crate::DecodeSoapResponse for GetGroupVolumeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetGroupMute", ns(SERVICE_TYPE))]
    pub struct SetGroupMuteRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "DesiredMute", ns(""))]
        pub desired_mute: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetGroupVolume", ns(SERVICE_TYPE))]
    pub struct SetGroupVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// New volume between 0 and 100
        #[xml(rename = "DesiredVolume", ns(""))]
        pub desired_volume: u16,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetRelativeGroupVolume", ns(SERVICE_TYPE))]
    pub struct SetRelativeGroupVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// Number between -100 and +100
        #[xml(rename = "Adjustment", ns(""))]
        pub adjustment: i32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "SetRelativeGroupVolumeResponse", ns(SERVICE_TYPE))]
    pub struct SetRelativeGroupVolumeResponse {
        #[xml(rename = "NewVolume", ns(""))]
        pub new_volume: Option<u16>,
    }

    impl crate::DecodeSoapResponse for SetRelativeGroupVolumeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SnapshotGroupVolume", ns(SERVICE_TYPE))]
    pub struct SnapshotGroupVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    /// A parsed event produced by the `GroupRenderingControl` service.
    /// Use `SonosDevice::subscribe_group_rendering_control()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct GroupRenderingControlEvent {
        pub group_mute: Option<bool>,
        pub group_volume: Option<u16>,
        pub group_volume_changeable: Option<bool>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct GroupRenderingControlPropertySet {
        pub properties: Vec<GroupRenderingControlProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct GroupRenderingControlProperty {
        #[xml(rename = "GroupMute", ns(""))]
        pub group_mute: Option<bool>,
        #[xml(rename = "GroupVolume", ns(""))]
        pub group_volume: Option<u16>,
        #[xml(rename = "GroupVolumeChangeable", ns(""))]
        pub group_volume_changeable: Option<bool>,
    }

    impl crate::upnp::DecodeXml for GroupRenderingControlEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: GroupRenderingControlPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.group_mute {
                    result.group_mute.replace(v);
                }

                if let Some(v) = prop.group_volume {
                    result.group_volume.replace(v);
                }

                if let Some(v) = prop.group_volume_changeable {
                    result.group_volume_changeable.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `GroupRenderingControl` service on this device
        pub async fn subscribe_group_rendering_control(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<GroupRenderingControlEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

/// Request and Response types for the `HTControl` service.
pub mod ht_control {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `HTControl` service.
    /// `urn:schemas-upnp-org:service:HTControl:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:HTControl:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "CommitLearnedIRCodes", ns(SERVICE_TYPE))]
    pub struct CommitLearnedIrCodesRequest {
        #[xml(rename = "Name", ns(""))]
        pub name: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetIRRepeaterStateResponse", ns(SERVICE_TYPE))]
    pub struct GetIrRepeaterStateResponse {
        #[xml(rename = "CurrentIRRepeaterState", ns(""))]
        pub current_ir_repeater_state: Option<super::IRRepeaterState>,
    }

    impl crate::DecodeSoapResponse for GetIrRepeaterStateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetLEDFeedbackStateResponse", ns(SERVICE_TYPE))]
    pub struct GetLedFeedbackStateResponse {
        #[xml(rename = "LEDFeedbackState", ns(""))]
        pub led_feedback_state: Option<super::LEDFeedbackState>,
    }

    impl crate::DecodeSoapResponse for GetLedFeedbackStateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "IdentifyIRRemote", ns(SERVICE_TYPE))]
    pub struct IdentifyIrRemoteRequest {
        #[xml(rename = "Timeout", ns(""))]
        pub timeout: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "IsRemoteConfiguredResponse", ns(SERVICE_TYPE))]
    pub struct IsRemoteConfiguredResponse {
        #[xml(rename = "RemoteConfigured", ns(""))]
        pub remote_configured: Option<bool>,
    }

    impl crate::DecodeSoapResponse for IsRemoteConfiguredResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "LearnIRCode", ns(SERVICE_TYPE))]
    pub struct LearnIrCodeRequest {
        #[xml(rename = "IRCode", ns(""))]
        pub ir_code: String,
        #[xml(rename = "Timeout", ns(""))]
        pub timeout: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetIRRepeaterState", ns(SERVICE_TYPE))]
    pub struct SetIrRepeaterStateRequest {
        #[xml(rename = "DesiredIRRepeaterState", ns(""))]
        pub desired_ir_repeater_state: super::IRRepeaterState,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetLEDFeedbackState", ns(SERVICE_TYPE))]
    pub struct SetLedFeedbackStateRequest {
        #[xml(rename = "LEDFeedbackState", ns(""))]
        pub led_feedback_state: super::LEDFeedbackState,
    }

    /// A parsed event produced by the `HTControl` service.
    /// Use `SonosDevice::subscribe_ht_control()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct HTControlEvent {
        pub ir_repeater_state: Option<super::IRRepeaterState>,
        pub tos_link_connected: Option<bool>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct HTControlPropertySet {
        pub properties: Vec<HTControlProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct HTControlProperty {
        #[xml(rename = "IRRepeaterState", ns(""))]
        pub ir_repeater_state: Option<super::IRRepeaterState>,
        #[xml(rename = "TOSLinkConnected", ns(""))]
        pub tos_link_connected: Option<bool>,
    }

    impl crate::upnp::DecodeXml for HTControlEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: HTControlPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.ir_repeater_state {
                    result.ir_repeater_state.replace(v);
                }

                if let Some(v) = prop.tos_link_connected {
                    result.tos_link_connected.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `HTControl` service on this device
        pub async fn subscribe_ht_control(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<HTControlEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum IRRepeaterState {
    #[default]
    On,
    Off,
    Disabled,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for IRRepeaterState {
    fn to_string(&self) -> String {
        match self {
            IRRepeaterState::On => "On".to_string(),
            IRRepeaterState::Off => "Off".to_string(),
            IRRepeaterState::Disabled => "Disabled".to_string(),
            IRRepeaterState::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for IRRepeaterState {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<IRRepeaterState> {
        match s {
            "On" => Ok(IRRepeaterState::On),
            "Off" => Ok(IRRepeaterState::Off),
            "Disabled" => Ok(IRRepeaterState::Disabled),
            s => Ok(IRRepeaterState::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for IRRepeaterState {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for IRRepeaterState {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: IRRepeaterState = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<IRRepeaterState>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum LEDFeedbackState {
    #[default]
    On,
    Off,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for LEDFeedbackState {
    fn to_string(&self) -> String {
        match self {
            LEDFeedbackState::On => "On".to_string(),
            LEDFeedbackState::Off => "Off".to_string(),
            LEDFeedbackState::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for LEDFeedbackState {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<LEDFeedbackState> {
        match s {
            "On" => Ok(LEDFeedbackState::On),
            "Off" => Ok(LEDFeedbackState::Off),
            s => Ok(LEDFeedbackState::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for LEDFeedbackState {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for LEDFeedbackState {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: LEDFeedbackState = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<LEDFeedbackState>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

/// Request and Response types for the `MusicServices` service.
pub mod music_services {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `MusicServices` service.
    /// `urn:schemas-upnp-org:service:MusicServices:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:MusicServices:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetSessionId", ns(SERVICE_TYPE))]
    pub struct GetSessionIdRequest {
        #[xml(rename = "ServiceId", ns(""))]
        pub service_id: u32,
        #[xml(rename = "Username", ns(""))]
        pub username: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetSessionIdResponse", ns(SERVICE_TYPE))]
    pub struct GetSessionIdResponse {
        #[xml(rename = "SessionId", ns(""))]
        pub session_id: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetSessionIdResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "ListAvailableServicesResponse", ns(SERVICE_TYPE))]
    pub struct ListAvailableServicesResponse {
        #[xml(rename = "AvailableServiceDescriptorList", ns(""))]
        pub available_service_descriptor_list: Option<String>,
        #[xml(rename = "AvailableServiceTypeList", ns(""))]
        pub available_service_type_list: Option<String>,
        #[xml(rename = "AvailableServiceListVersion", ns(""))]
        pub available_service_list_version: Option<String>,
    }

    impl crate::DecodeSoapResponse for ListAvailableServicesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    /// A parsed event produced by the `MusicServices` service.
    /// Use `SonosDevice::subscribe_music_services()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct MusicServicesEvent {
        pub service_list_version: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct MusicServicesPropertySet {
        pub properties: Vec<MusicServicesProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct MusicServicesProperty {
        #[xml(rename = "ServiceListVersion", ns(""))]
        pub service_list_version: Option<String>,
    }

    impl crate::upnp::DecodeXml for MusicServicesEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: MusicServicesPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.service_list_version {
                    result.service_list_version.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `MusicServices` service on this device
        pub async fn subscribe_music_services(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<MusicServicesEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

/// Request and Response types for the `QPlay` service.
pub mod q_play {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `QPlay` service.
    /// `urn:schemas-tencent-com:service:QPlay:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-tencent-com:service:QPlay:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "QPlayAuth", ns(SERVICE_TYPE))]
    pub struct QPlayAuthRequest {
        #[xml(rename = "Seed", ns(""))]
        pub seed: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "QPlayAuthResponse", ns(SERVICE_TYPE))]
    pub struct QPlayAuthResponse {
        #[xml(rename = "Code", ns(""))]
        pub code: Option<String>,
        #[xml(rename = "MID", ns(""))]
        pub mid: Option<String>,
        #[xml(rename = "DID", ns(""))]
        pub did: Option<String>,
    }

    impl crate::DecodeSoapResponse for QPlayAuthResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }
}

/// Request and Response types for the `Queue` service.
pub mod queue {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `Queue` service.
    /// `urn:schemas-sonos-com:service:Queue:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-sonos-com:service:Queue:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddMultipleURIs", ns(SERVICE_TYPE))]
    pub struct AddMultipleUrisRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        #[xml(rename = "ContainerURI", ns(""))]
        pub container_uri: String,
        #[xml(rename = "ContainerMetaData", ns(""))]
        pub container_meta_data: String,
        #[xml(rename = "DesiredFirstTrackNumberEnqueued", ns(""))]
        pub desired_first_track_number_enqueued: u32,
        #[xml(rename = "EnqueueAsNext", ns(""))]
        pub enqueue_as_next: bool,
        #[xml(rename = "NumberOfURIs", ns(""))]
        pub number_of_uris: u32,
        #[xml(rename = "EnqueuedURIsAndMetaData", ns(""))]
        pub enqueued_uris_and_meta_data: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddMultipleURIsResponse", ns(SERVICE_TYPE))]
    pub struct AddMultipleUrisResponse {
        #[xml(rename = "FirstTrackNumberEnqueued", ns(""))]
        pub first_track_number_enqueued: Option<u32>,
        #[xml(rename = "NumTracksAdded", ns(""))]
        pub num_tracks_added: Option<u32>,
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for AddMultipleUrisResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddURI", ns(SERVICE_TYPE))]
    pub struct AddUriRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        #[xml(rename = "EnqueuedURI", ns(""))]
        pub enqueued_uri: String,
        #[xml(rename = "EnqueuedURIMetaData", ns(""))]
        pub enqueued_uri_meta_data: String,
        #[xml(rename = "DesiredFirstTrackNumberEnqueued", ns(""))]
        pub desired_first_track_number_enqueued: u32,
        #[xml(rename = "EnqueueAsNext", ns(""))]
        pub enqueue_as_next: bool,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddURIResponse", ns(SERVICE_TYPE))]
    pub struct AddUriResponse {
        #[xml(rename = "FirstTrackNumberEnqueued", ns(""))]
        pub first_track_number_enqueued: Option<u32>,
        #[xml(rename = "NumTracksAdded", ns(""))]
        pub num_tracks_added: Option<u32>,
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for AddUriResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AttachQueue", ns(SERVICE_TYPE))]
    pub struct AttachQueueRequest {
        #[xml(rename = "QueueOwnerID", ns(""))]
        pub queue_owner_id: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AttachQueueResponse", ns(SERVICE_TYPE))]
    pub struct AttachQueueResponse {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: Option<u32>,
        #[xml(rename = "QueueOwnerContext", ns(""))]
        pub queue_owner_context: Option<String>,
    }

    impl crate::DecodeSoapResponse for AttachQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Browse", ns(SERVICE_TYPE))]
    pub struct BrowseRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "StartingIndex", ns(""))]
        pub starting_index: u32,
        #[xml(rename = "RequestedCount", ns(""))]
        pub requested_count: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "BrowseResponse", ns(SERVICE_TYPE))]
    pub struct BrowseResponse {
        #[xml(rename = "Result", ns(""))]
        pub result: Option<crate::xmlutil::DecodeXmlString<crate::TrackMetaDataList>>,
        #[xml(rename = "NumberReturned", ns(""))]
        pub number_returned: Option<u32>,
        #[xml(rename = "TotalMatches", ns(""))]
        pub total_matches: Option<u32>,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for BrowseResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "CreateQueue", ns(SERVICE_TYPE))]
    pub struct CreateQueueRequest {
        #[xml(rename = "QueueOwnerID", ns(""))]
        pub queue_owner_id: String,
        #[xml(rename = "QueueOwnerContext", ns(""))]
        pub queue_owner_context: String,
        #[xml(rename = "QueuePolicy", ns(""))]
        pub queue_policy: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "CreateQueueResponse", ns(SERVICE_TYPE))]
    pub struct CreateQueueResponse {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for CreateQueueResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveAllTracks", ns(SERVICE_TYPE))]
    pub struct RemoveAllTracksRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "RemoveAllTracksResponse", ns(SERVICE_TYPE))]
    pub struct RemoveAllTracksResponse {
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for RemoveAllTracksResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveTrackRange", ns(SERVICE_TYPE))]
    pub struct RemoveTrackRangeRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        #[xml(rename = "StartingIndex", ns(""))]
        pub starting_index: u32,
        #[xml(rename = "NumberOfTracks", ns(""))]
        pub number_of_tracks: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "RemoveTrackRangeResponse", ns(SERVICE_TYPE))]
    pub struct RemoveTrackRangeResponse {
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for RemoveTrackRangeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ReorderTracks", ns(SERVICE_TYPE))]
    pub struct ReorderTracksRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "StartingIndex", ns(""))]
        pub starting_index: u32,
        #[xml(rename = "NumberOfTracks", ns(""))]
        pub number_of_tracks: u32,
        #[xml(rename = "InsertBefore", ns(""))]
        pub insert_before: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "ReorderTracksResponse", ns(SERVICE_TYPE))]
    pub struct ReorderTracksResponse {
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for ReorderTracksResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ReplaceAllTracks", ns(SERVICE_TYPE))]
    pub struct ReplaceAllTracksRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: u32,
        #[xml(rename = "ContainerURI", ns(""))]
        pub container_uri: String,
        #[xml(rename = "ContainerMetaData", ns(""))]
        pub container_meta_data: String,
        #[xml(rename = "CurrentTrackIndex", ns(""))]
        pub current_track_index: u32,
        #[xml(rename = "NewCurrentTrackIndices", ns(""))]
        pub new_current_track_indices: String,
        #[xml(rename = "NumberOfURIs", ns(""))]
        pub number_of_uris: u32,
        #[xml(rename = "EnqueuedURIsAndMetaData", ns(""))]
        pub enqueued_uris_and_meta_data: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "ReplaceAllTracksResponse", ns(SERVICE_TYPE))]
    pub struct ReplaceAllTracksResponse {
        #[xml(rename = "NewQueueLength", ns(""))]
        pub new_queue_length: Option<u32>,
        #[xml(rename = "NewUpdateID", ns(""))]
        pub new_update_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for ReplaceAllTracksResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SaveAsSonosPlaylist", ns(SERVICE_TYPE))]
    pub struct SaveAsSonosPlaylistRequest {
        #[xml(rename = "QueueID", ns(""))]
        pub queue_id: u32,
        #[xml(rename = "Title", ns(""))]
        pub title: String,
        #[xml(rename = "ObjectID", ns(""))]
        pub object_id: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "SaveAsSonosPlaylistResponse", ns(SERVICE_TYPE))]
    pub struct SaveAsSonosPlaylistResponse {
        #[xml(rename = "AssignedObjectID", ns(""))]
        pub assigned_object_id: Option<String>,
    }

    impl crate::DecodeSoapResponse for SaveAsSonosPlaylistResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    /// A parsed event produced by the `Queue` service.
    /// Use `SonosDevice::subscribe_queue()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct QueueEvent {
        pub last_change: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct QueuePropertySet {
        pub properties: Vec<QueueProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct QueueProperty {
        #[xml(rename = "LastChange", ns(""))]
        pub last_change: Option<String>,
    }

    impl crate::upnp::DecodeXml for QueueEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: QueuePropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.last_change {
                    result.last_change.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `Queue` service on this device
        pub async fn subscribe_queue(&self) -> crate::Result<crate::upnp::EventStream<QueueEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

/// Request and Response types for the `RenderingControl` service.
pub mod rendering_control {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `RenderingControl` service.
    /// `urn:schemas-upnp-org:service:RenderingControl:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:RenderingControl:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetBass", ns(SERVICE_TYPE))]
    pub struct GetBassRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetBassResponse", ns(SERVICE_TYPE))]
    pub struct GetBassResponse {
        #[xml(rename = "CurrentBass", ns(""))]
        pub current_bass: Option<i16>,
    }

    impl crate::DecodeSoapResponse for GetBassResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetEQ", ns(SERVICE_TYPE))]
    pub struct GetEqRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// Allowed values `DialogLevel` (bool) / `MusicSurroundLevel` (-15/+15) /  `NightMode` (bool) / `SubGain` (-10/+10) / `SurroundEnable` (bool) / `SurroundLevel` (-15/+15) / `SurroundMode` (0 = ambient, 1 = full) / `HeightChannelLevel` (-10/+10)
        #[xml(rename = "EQType", ns(""))]
        pub eq_type: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetEQResponse", ns(SERVICE_TYPE))]
    pub struct GetEqResponse {
        #[xml(rename = "CurrentValue", ns(""))]
        pub current_value: Option<i16>,
    }

    impl crate::DecodeSoapResponse for GetEqResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetHeadphoneConnected", ns(SERVICE_TYPE))]
    pub struct GetHeadphoneConnectedRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetHeadphoneConnectedResponse", ns(SERVICE_TYPE))]
    pub struct GetHeadphoneConnectedResponse {
        #[xml(rename = "CurrentHeadphoneConnected", ns(""))]
        pub current_headphone_connected: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetHeadphoneConnectedResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetLoudness", ns(SERVICE_TYPE))]
    pub struct GetLoudnessRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetLoudnessResponse", ns(SERVICE_TYPE))]
    pub struct GetLoudnessResponse {
        #[xml(rename = "CurrentLoudness", ns(""))]
        pub current_loudness: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetLoudnessResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetMute", ns(SERVICE_TYPE))]
    pub struct GetMuteRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::MuteChannel,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetMuteResponse", ns(SERVICE_TYPE))]
    pub struct GetMuteResponse {
        #[xml(rename = "CurrentMute", ns(""))]
        pub current_mute: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetMuteResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetOutputFixed", ns(SERVICE_TYPE))]
    pub struct GetOutputFixedRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetOutputFixedResponse", ns(SERVICE_TYPE))]
    pub struct GetOutputFixedResponse {
        #[xml(rename = "CurrentFixed", ns(""))]
        pub current_fixed: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetOutputFixedResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetRoomCalibrationStatus", ns(SERVICE_TYPE))]
    pub struct GetRoomCalibrationStatusRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetRoomCalibrationStatusResponse", ns(SERVICE_TYPE))]
    pub struct GetRoomCalibrationStatusResponse {
        #[xml(rename = "RoomCalibrationEnabled", ns(""))]
        pub room_calibration_enabled: Option<bool>,
        #[xml(rename = "RoomCalibrationAvailable", ns(""))]
        pub room_calibration_available: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetRoomCalibrationStatusResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetSupportsOutputFixed", ns(SERVICE_TYPE))]
    pub struct GetSupportsOutputFixedRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetSupportsOutputFixedResponse", ns(SERVICE_TYPE))]
    pub struct GetSupportsOutputFixedResponse {
        #[xml(rename = "CurrentSupportsFixed", ns(""))]
        pub current_supports_fixed: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetSupportsOutputFixedResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetTreble", ns(SERVICE_TYPE))]
    pub struct GetTrebleRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetTrebleResponse", ns(SERVICE_TYPE))]
    pub struct GetTrebleResponse {
        #[xml(rename = "CurrentTreble", ns(""))]
        pub current_treble: Option<i16>,
    }

    impl crate::DecodeSoapResponse for GetTrebleResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetVolume", ns(SERVICE_TYPE))]
    pub struct GetVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetVolumeResponse", ns(SERVICE_TYPE))]
    pub struct GetVolumeResponse {
        #[xml(rename = "CurrentVolume", ns(""))]
        pub current_volume: Option<u16>,
    }

    impl crate::DecodeSoapResponse for GetVolumeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetVolumeDB", ns(SERVICE_TYPE))]
    pub struct GetVolumeDbRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetVolumeDBResponse", ns(SERVICE_TYPE))]
    pub struct GetVolumeDbResponse {
        #[xml(rename = "CurrentVolume", ns(""))]
        pub current_volume: Option<i16>,
    }

    impl crate::DecodeSoapResponse for GetVolumeDbResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetVolumeDBRange", ns(SERVICE_TYPE))]
    pub struct GetVolumeDbRangeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetVolumeDBRangeResponse", ns(SERVICE_TYPE))]
    pub struct GetVolumeDbRangeResponse {
        #[xml(rename = "MinValue", ns(""))]
        pub min_value: Option<i16>,
        #[xml(rename = "MaxValue", ns(""))]
        pub max_value: Option<i16>,
    }

    impl crate::DecodeSoapResponse for GetVolumeDbRangeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RampToVolume", ns(SERVICE_TYPE))]
    pub struct RampToVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
        #[xml(rename = "RampType", ns(""))]
        pub ramp_type: super::RampType,
        #[xml(rename = "DesiredVolume", ns(""))]
        pub desired_volume: u16,
        #[xml(rename = "ResetVolumeAfter", ns(""))]
        pub reset_volume_after: bool,
        #[xml(rename = "ProgramURI", ns(""))]
        pub program_uri: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "RampToVolumeResponse", ns(SERVICE_TYPE))]
    pub struct RampToVolumeResponse {
        #[xml(rename = "RampTime", ns(""))]
        pub ramp_time: Option<u32>,
    }

    impl crate::DecodeSoapResponse for RampToVolumeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ResetBasicEQ", ns(SERVICE_TYPE))]
    pub struct ResetBasicEqRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "ResetBasicEQResponse", ns(SERVICE_TYPE))]
    pub struct ResetBasicEqResponse {
        #[xml(rename = "Bass", ns(""))]
        pub bass: Option<i16>,
        #[xml(rename = "Treble", ns(""))]
        pub treble: Option<i16>,
        #[xml(rename = "Loudness", ns(""))]
        pub loudness: Option<bool>,
        #[xml(rename = "LeftVolume", ns(""))]
        pub left_volume: Option<u16>,
        #[xml(rename = "RightVolume", ns(""))]
        pub right_volume: Option<u16>,
    }

    impl crate::DecodeSoapResponse for ResetBasicEqResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ResetExtEQ", ns(SERVICE_TYPE))]
    pub struct ResetExtEqRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "EQType", ns(""))]
        pub eq_type: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RestoreVolumePriorToRamp", ns(SERVICE_TYPE))]
    pub struct RestoreVolumePriorToRampRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetBass", ns(SERVICE_TYPE))]
    pub struct SetBassRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "DesiredBass", ns(""))]
        pub desired_bass: i16,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetChannelMap", ns(SERVICE_TYPE))]
    pub struct SetChannelMapRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "ChannelMap", ns(""))]
        pub channel_map: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetEQ", ns(SERVICE_TYPE))]
    pub struct SetEqRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// Allowed values `DialogLevel` (bool) / `MusicSurroundLevel` (-15/+15) /  `NightMode` (bool) / `SubGain` (-10/+10) / `SurroundEnable` (bool) / `SurroundLevel` (-15/+15) / `SurroundMode` (0 = ambient, 1 = full) / `HeightChannelLevel` (-10/+10)
        #[xml(rename = "EQType", ns(""))]
        pub eq_type: String,
        /// Booleans required `1` for true or `0` for false, rest number as specified
        #[xml(rename = "DesiredValue", ns(""))]
        pub desired_value: i16,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetLoudness", ns(SERVICE_TYPE))]
    pub struct SetLoudnessRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
        #[xml(rename = "DesiredLoudness", ns(""))]
        pub desired_loudness: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetMute", ns(SERVICE_TYPE))]
    pub struct SetMuteRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::MuteChannel,
        #[xml(rename = "DesiredMute", ns(""))]
        pub desired_mute: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetOutputFixed", ns(SERVICE_TYPE))]
    pub struct SetOutputFixedRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "DesiredFixed", ns(""))]
        pub desired_fixed: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetRelativeVolume", ns(SERVICE_TYPE))]
    pub struct SetRelativeVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
        #[xml(rename = "Adjustment", ns(""))]
        pub adjustment: i32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "SetRelativeVolumeResponse", ns(SERVICE_TYPE))]
    pub struct SetRelativeVolumeResponse {
        #[xml(rename = "NewVolume", ns(""))]
        pub new_volume: Option<u16>,
    }

    impl crate::DecodeSoapResponse for SetRelativeVolumeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetRoomCalibrationStatus", ns(SERVICE_TYPE))]
    pub struct SetRoomCalibrationStatusRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "RoomCalibrationEnabled", ns(""))]
        pub room_calibration_enabled: bool,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetRoomCalibrationX", ns(SERVICE_TYPE))]
    pub struct SetRoomCalibrationXRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "CalibrationID", ns(""))]
        pub calibration_id: String,
        #[xml(rename = "Coefficients", ns(""))]
        pub coefficients: String,
        #[xml(rename = "CalibrationMode", ns(""))]
        pub calibration_mode: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetTreble", ns(SERVICE_TYPE))]
    pub struct SetTrebleRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        /// between -10 and 10
        #[xml(rename = "DesiredTreble", ns(""))]
        pub desired_treble: i16,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetVolume", ns(SERVICE_TYPE))]
    pub struct SetVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
        #[xml(rename = "DesiredVolume", ns(""))]
        pub desired_volume: u16,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetVolumeDB", ns(SERVICE_TYPE))]
    pub struct SetVolumeDbRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Channel", ns(""))]
        pub channel: super::Channel,
        #[xml(rename = "DesiredVolume", ns(""))]
        pub desired_volume: i16,
    }

    /// A parsed event produced by the `RenderingControl` service.
    /// Use `SonosDevice::subscribe_rendering_control()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct RenderingControlEvent {
        pub last_change: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct RenderingControlPropertySet {
        pub properties: Vec<RenderingControlProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct RenderingControlProperty {
        #[xml(rename = "LastChange", ns(""))]
        pub last_change: Option<String>,
    }

    impl crate::upnp::DecodeXml for RenderingControlEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: RenderingControlPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.last_change {
                    result.last_change.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `RenderingControl` service on this device
        pub async fn subscribe_rendering_control(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<RenderingControlEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum Channel {
    #[default]
    Master,
    Lf,
    Rf,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for Channel {
    fn to_string(&self) -> String {
        match self {
            Channel::Master => "Master".to_string(),
            Channel::Lf => "LF".to_string(),
            Channel::Rf => "RF".to_string(),
            Channel::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for Channel {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<Channel> {
        match s {
            "Master" => Ok(Channel::Master),
            "LF" => Ok(Channel::Lf),
            "RF" => Ok(Channel::Rf),
            s => Ok(Channel::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for Channel {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for Channel {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: Channel = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<Channel>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum MuteChannel {
    #[default]
    Master,
    Lf,
    Rf,
    SpeakerOnly,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for MuteChannel {
    fn to_string(&self) -> String {
        match self {
            MuteChannel::Master => "Master".to_string(),
            MuteChannel::Lf => "LF".to_string(),
            MuteChannel::Rf => "RF".to_string(),
            MuteChannel::SpeakerOnly => "SpeakerOnly".to_string(),
            MuteChannel::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for MuteChannel {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<MuteChannel> {
        match s {
            "Master" => Ok(MuteChannel::Master),
            "LF" => Ok(MuteChannel::Lf),
            "RF" => Ok(MuteChannel::Rf),
            "SpeakerOnly" => Ok(MuteChannel::SpeakerOnly),
            s => Ok(MuteChannel::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for MuteChannel {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for MuteChannel {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: MuteChannel = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<MuteChannel>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum RampType {
    #[default]
    SleepTimerRampType,
    AlarmRampType,
    AutoplayRampType,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for RampType {
    fn to_string(&self) -> String {
        match self {
            RampType::SleepTimerRampType => "SLEEP_TIMER_RAMP_TYPE".to_string(),
            RampType::AlarmRampType => "ALARM_RAMP_TYPE".to_string(),
            RampType::AutoplayRampType => "AUTOPLAY_RAMP_TYPE".to_string(),
            RampType::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for RampType {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<RampType> {
        match s {
            "SLEEP_TIMER_RAMP_TYPE" => Ok(RampType::SleepTimerRampType),
            "ALARM_RAMP_TYPE" => Ok(RampType::AlarmRampType),
            "AUTOPLAY_RAMP_TYPE" => Ok(RampType::AutoplayRampType),
            s => Ok(RampType::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for RampType {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for RampType {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: RampType = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<RampType>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

/// Request and Response types for the `SystemProperties` service.
pub mod system_properties {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `SystemProperties` service.
    /// `urn:schemas-upnp-org:service:SystemProperties:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:SystemProperties:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddAccountX", ns(SERVICE_TYPE))]
    pub struct AddAccountXRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
        #[xml(rename = "AccountID", ns(""))]
        pub account_id: String,
        #[xml(rename = "AccountPassword", ns(""))]
        pub account_password: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddAccountXResponse", ns(SERVICE_TYPE))]
    pub struct AddAccountXResponse {
        #[xml(rename = "AccountUDN", ns(""))]
        pub account_udn: Option<String>,
    }

    impl crate::DecodeSoapResponse for AddAccountXResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "AddOAuthAccountX", ns(SERVICE_TYPE))]
    pub struct AddOAuthAccountXRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
        #[xml(rename = "AccountToken", ns(""))]
        pub account_token: String,
        #[xml(rename = "AccountKey", ns(""))]
        pub account_key: String,
        #[xml(rename = "OAuthDeviceID", ns(""))]
        pub o_auth_device_id: String,
        #[xml(rename = "AuthorizationCode", ns(""))]
        pub authorization_code: String,
        #[xml(rename = "RedirectURI", ns(""))]
        pub redirect_uri: String,
        #[xml(rename = "UserIdHashCode", ns(""))]
        pub user_id_hash_code: String,
        #[xml(rename = "AccountTier", ns(""))]
        pub account_tier: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "AddOAuthAccountXResponse", ns(SERVICE_TYPE))]
    pub struct AddOAuthAccountXResponse {
        #[xml(rename = "AccountUDN", ns(""))]
        pub account_udn: Option<String>,
        #[xml(rename = "AccountNickname", ns(""))]
        pub account_nickname: Option<String>,
    }

    impl crate::DecodeSoapResponse for AddOAuthAccountXResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "EditAccountMd", ns(SERVICE_TYPE))]
    pub struct EditAccountMdRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
        #[xml(rename = "AccountID", ns(""))]
        pub account_id: String,
        #[xml(rename = "NewAccountMd", ns(""))]
        pub new_account_md: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "EditAccountPasswordX", ns(SERVICE_TYPE))]
    pub struct EditAccountPasswordXRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
        #[xml(rename = "AccountID", ns(""))]
        pub account_id: String,
        #[xml(rename = "NewAccountPassword", ns(""))]
        pub new_account_password: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "EnableRDM", ns(SERVICE_TYPE))]
    pub struct EnableRdmRequest {
        #[xml(rename = "RDMValue", ns(""))]
        pub rdm_value: bool,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetRDMResponse", ns(SERVICE_TYPE))]
    pub struct GetRdmResponse {
        #[xml(rename = "RDMValue", ns(""))]
        pub rdm_value: Option<bool>,
    }

    impl crate::DecodeSoapResponse for GetRdmResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetString", ns(SERVICE_TYPE))]
    pub struct GetStringRequest {
        /// The key for this variable
        #[xml(rename = "VariableName", ns(""))]
        pub variable_name: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetStringResponse", ns(SERVICE_TYPE))]
    pub struct GetStringResponse {
        #[xml(rename = "StringValue", ns(""))]
        pub string_value: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetStringResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "GetWebCode", ns(SERVICE_TYPE))]
    pub struct GetWebCodeRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetWebCodeResponse", ns(SERVICE_TYPE))]
    pub struct GetWebCodeResponse {
        #[xml(rename = "WebCode", ns(""))]
        pub web_code: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetWebCodeResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ProvisionCredentialedTrialAccountX", ns(SERVICE_TYPE))]
    pub struct ProvisionCredentialedTrialAccountXRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
        #[xml(rename = "AccountID", ns(""))]
        pub account_id: String,
        #[xml(rename = "AccountPassword", ns(""))]
        pub account_password: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(
        rename = "ProvisionCredentialedTrialAccountXResponse",
        ns(SERVICE_TYPE)
    )]
    pub struct ProvisionCredentialedTrialAccountXResponse {
        #[xml(rename = "IsExpired", ns(""))]
        pub is_expired: Option<bool>,
        #[xml(rename = "AccountUDN", ns(""))]
        pub account_udn: Option<String>,
    }

    impl crate::DecodeSoapResponse for ProvisionCredentialedTrialAccountXResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RefreshAccountCredentialsX", ns(SERVICE_TYPE))]
    pub struct RefreshAccountCredentialsXRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
        #[xml(rename = "AccountUID", ns(""))]
        pub account_uid: u32,
        #[xml(rename = "AccountToken", ns(""))]
        pub account_token: String,
        #[xml(rename = "AccountKey", ns(""))]
        pub account_key: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Remove", ns(SERVICE_TYPE))]
    pub struct RemoveRequest {
        /// The key for this variable
        #[xml(rename = "VariableName", ns(""))]
        pub variable_name: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RemoveAccount", ns(SERVICE_TYPE))]
    pub struct RemoveAccountRequest {
        #[xml(rename = "AccountType", ns(""))]
        pub account_type: u32,
        #[xml(rename = "AccountID", ns(""))]
        pub account_id: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ReplaceAccountX", ns(SERVICE_TYPE))]
    pub struct ReplaceAccountXRequest {
        #[xml(rename = "AccountUDN", ns(""))]
        pub account_udn: String,
        #[xml(rename = "NewAccountID", ns(""))]
        pub new_account_id: String,
        #[xml(rename = "NewAccountPassword", ns(""))]
        pub new_account_password: String,
        #[xml(rename = "AccountToken", ns(""))]
        pub account_token: String,
        #[xml(rename = "AccountKey", ns(""))]
        pub account_key: String,
        #[xml(rename = "OAuthDeviceID", ns(""))]
        pub o_auth_device_id: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "ReplaceAccountXResponse", ns(SERVICE_TYPE))]
    pub struct ReplaceAccountXResponse {
        #[xml(rename = "NewAccountUDN", ns(""))]
        pub new_account_udn: Option<String>,
    }

    impl crate::DecodeSoapResponse for ReplaceAccountXResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetAccountNicknameX", ns(SERVICE_TYPE))]
    pub struct SetAccountNicknameXRequest {
        #[xml(rename = "AccountUDN", ns(""))]
        pub account_udn: String,
        #[xml(rename = "AccountNickname", ns(""))]
        pub account_nickname: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetString", ns(SERVICE_TYPE))]
    pub struct SetStringRequest {
        /// The key for this variable, use something unique
        #[xml(rename = "VariableName", ns(""))]
        pub variable_name: String,
        #[xml(rename = "StringValue", ns(""))]
        pub string_value: String,
    }

    /// A parsed event produced by the `SystemProperties` service.
    /// Use `SonosDevice::subscribe_system_properties()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct SystemPropertiesEvent {
        pub customer_id: Option<String>,
        pub third_party_hash: Option<String>,
        pub update_id: Option<u32>,
        pub update_idx: Option<u32>,
        pub voice_update_id: Option<u32>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct SystemPropertiesPropertySet {
        pub properties: Vec<SystemPropertiesProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct SystemPropertiesProperty {
        #[xml(rename = "CustomerID", ns(""))]
        pub customer_id: Option<String>,
        #[xml(rename = "ThirdPartyHash", ns(""))]
        pub third_party_hash: Option<String>,
        #[xml(rename = "UpdateID", ns(""))]
        pub update_id: Option<u32>,
        #[xml(rename = "UpdateIDX", ns(""))]
        pub update_idx: Option<u32>,
        #[xml(rename = "VoiceUpdateID", ns(""))]
        pub voice_update_id: Option<u32>,
    }

    impl crate::upnp::DecodeXml for SystemPropertiesEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: SystemPropertiesPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.customer_id {
                    result.customer_id.replace(v);
                }

                if let Some(v) = prop.third_party_hash {
                    result.third_party_hash.replace(v);
                }

                if let Some(v) = prop.update_id {
                    result.update_id.replace(v);
                }

                if let Some(v) = prop.update_idx {
                    result.update_idx.replace(v);
                }

                if let Some(v) = prop.voice_update_id {
                    result.voice_update_id.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `SystemProperties` service on this device
        pub async fn subscribe_system_properties(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<SystemPropertiesEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

/// Request and Response types for the `VirtualLineIn` service.
pub mod virtual_line_in {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `VirtualLineIn` service.
    /// `urn:schemas-upnp-org:service:VirtualLineIn:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:VirtualLineIn:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Next", ns(SERVICE_TYPE))]
    pub struct NextRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Pause", ns(SERVICE_TYPE))]
    pub struct PauseRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Play", ns(SERVICE_TYPE))]
    pub struct PlayRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "Speed", ns(""))]
        pub speed: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Previous", ns(SERVICE_TYPE))]
    pub struct PreviousRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SetVolume", ns(SERVICE_TYPE))]
    pub struct SetVolumeRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "DesiredVolume", ns(""))]
        pub desired_volume: u16,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "StartTransmission", ns(SERVICE_TYPE))]
    pub struct StartTransmissionRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "CoordinatorID", ns(""))]
        pub coordinator_id: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "StartTransmissionResponse", ns(SERVICE_TYPE))]
    pub struct StartTransmissionResponse {
        #[xml(rename = "CurrentTransportSettings", ns(""))]
        pub current_transport_settings: Option<String>,
    }

    impl crate::DecodeSoapResponse for StartTransmissionResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "Stop", ns(SERVICE_TYPE))]
    pub struct StopRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "StopTransmission", ns(SERVICE_TYPE))]
    pub struct StopTransmissionRequest {
        #[xml(rename = "InstanceID", ns(""))]
        pub instance_id: u32,
        #[xml(rename = "CoordinatorID", ns(""))]
        pub coordinator_id: String,
    }

    /// A parsed event produced by the `VirtualLineIn` service.
    /// Use `SonosDevice::subscribe_virtual_line_in()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct VirtualLineInEvent {
        pub current_track_meta_data: Option<crate::xmlutil::DecodeXmlString<crate::TrackMetaData>>,
        pub last_change: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct VirtualLineInPropertySet {
        pub properties: Vec<VirtualLineInProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct VirtualLineInProperty {
        #[xml(rename = "CurrentTrackMetaData", ns(""))]
        pub current_track_meta_data: Option<crate::xmlutil::DecodeXmlString<crate::TrackMetaData>>,
        #[xml(rename = "LastChange", ns(""))]
        pub last_change: Option<String>,
    }

    impl crate::upnp::DecodeXml for VirtualLineInEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: VirtualLineInPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.current_track_meta_data {
                    result.current_track_meta_data.replace(v);
                }

                if let Some(v) = prop.last_change {
                    result.last_change.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `VirtualLineIn` service on this device
        pub async fn subscribe_virtual_line_in(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<VirtualLineInEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

/// Request and Response types for the `ZoneGroupTopology` service.
pub mod zone_group_topology {
    use instant_xml::{FromXml, ToXml};

    /// URN for the `ZoneGroupTopology` service.
    /// `urn:schemas-upnp-org:service:ZoneGroupTopology:1`
    pub const SERVICE_TYPE: &str = "urn:schemas-upnp-org:service:ZoneGroupTopology:1";

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "BeginSoftwareUpdate", ns(SERVICE_TYPE))]
    pub struct BeginSoftwareUpdateRequest {
        #[xml(rename = "UpdateURL", ns(""))]
        pub update_url: String,
        #[xml(rename = "Flags", ns(""))]
        pub flags: u32,
        #[xml(rename = "ExtraOptions", ns(""))]
        pub extra_options: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "CheckForUpdate", ns(SERVICE_TYPE))]
    pub struct CheckForUpdateRequest {
        #[xml(rename = "UpdateType", ns(""))]
        pub update_type: super::UpdateType,
        #[xml(rename = "CachedOnly", ns(""))]
        pub cached_only: bool,
        #[xml(rename = "Version", ns(""))]
        pub version: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "CheckForUpdateResponse", ns(SERVICE_TYPE))]
    pub struct CheckForUpdateResponse {
        #[xml(rename = "UpdateItem", ns(""))]
        pub update_item: Option<String>,
    }

    impl crate::DecodeSoapResponse for CheckForUpdateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetZoneGroupAttributesResponse", ns(SERVICE_TYPE))]
    pub struct GetZoneGroupAttributesResponse {
        #[xml(rename = "CurrentZoneGroupName", ns(""))]
        pub current_zone_group_name: Option<String>,
        #[xml(rename = "CurrentZoneGroupID", ns(""))]
        pub current_zone_group_id: Option<String>,
        #[xml(rename = "CurrentZonePlayerUUIDsInGroup", ns(""))]
        pub current_zone_player_uuids_in_group: Option<String>,
        #[xml(rename = "CurrentMuseHouseholdId", ns(""))]
        pub current_muse_household_id: Option<String>,
    }

    impl crate::DecodeSoapResponse for GetZoneGroupAttributesResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "GetZoneGroupStateResponse", ns(SERVICE_TYPE))]
    pub struct GetZoneGroupStateResponse {
        #[xml(rename = "ZoneGroupState", ns(""))]
        pub zone_group_state: Option<crate::xmlutil::DecodeXmlString<crate::ZoneGroupState>>,
    }

    impl crate::DecodeSoapResponse for GetZoneGroupStateResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "RegisterMobileDevice", ns(SERVICE_TYPE))]
    pub struct RegisterMobileDeviceRequest {
        #[xml(rename = "MobileDeviceName", ns(""))]
        pub mobile_device_name: String,
        #[xml(rename = "MobileDeviceUDN", ns(""))]
        pub mobile_device_udn: String,
        #[xml(rename = "MobileIPAndPort", ns(""))]
        pub mobile_ip_and_port: String,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "ReportUnresponsiveDevice", ns(SERVICE_TYPE))]
    pub struct ReportUnresponsiveDeviceRequest {
        #[xml(rename = "DeviceUUID", ns(""))]
        pub device_uuid: String,
        #[xml(rename = "DesiredAction", ns(""))]
        pub desired_action: super::UnresponsiveDeviceActionType,
    }

    #[derive(ToXml, Debug, Clone, PartialEq, Default)]
    #[xml(rename = "SubmitDiagnostics", ns(SERVICE_TYPE))]
    pub struct SubmitDiagnosticsRequest {
        #[xml(rename = "IncludeControllers", ns(""))]
        pub include_controllers: bool,
        #[xml(rename = "Type", ns(""))]
        pub type_: String,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename = "SubmitDiagnosticsResponse", ns(SERVICE_TYPE))]
    pub struct SubmitDiagnosticsResponse {
        #[xml(rename = "DiagnosticID", ns(""))]
        pub diagnostic_id: Option<u32>,
    }

    impl crate::DecodeSoapResponse for SubmitDiagnosticsResponse {
        fn decode_soap_xml(xml: &str) -> crate::Result<Self> {
            let envelope: crate::soap_resp::Envelope<Self> = instant_xml::from_str(xml)?;
            Ok(envelope.body.payload)
        }
    }

    /// A parsed event produced by the `ZoneGroupTopology` service.
    /// Use `SonosDevice::subscribe_zone_group_topology()` to obtain an event
    /// stream that produces these.
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct ZoneGroupTopologyEvent {
        pub alarm_run_sequence: Option<String>,
        pub areas_update_id: Option<String>,
        pub available_software_update: Option<String>,
        pub muse_household_id: Option<String>,
        pub netsettings_update_id: Option<String>,
        pub source_areas_update_id: Option<String>,
        pub third_party_media_servers_x: Option<String>,
        pub zone_group_id: Option<String>,
        pub zone_group_name: Option<String>,
        pub zone_group_state: Option<crate::xmlutil::DecodeXmlString<crate::ZoneGroupState>>,
        pub zone_player_uuids_in_group: Option<String>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="propertyset", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct ZoneGroupTopologyPropertySet {
        pub properties: Vec<ZoneGroupTopologyProperty>,
    }

    #[derive(FromXml, Debug, Clone, PartialEq)]
    #[xml(rename="property", ns(crate::upnp::UPNP_EVENT, e=crate::upnp::UPNP_EVENT))]
    struct ZoneGroupTopologyProperty {
        #[xml(rename = "AlarmRunSequence", ns(""))]
        pub alarm_run_sequence: Option<String>,
        #[xml(rename = "AreasUpdateID", ns(""))]
        pub areas_update_id: Option<String>,
        #[xml(rename = "AvailableSoftwareUpdate", ns(""))]
        pub available_software_update: Option<String>,
        #[xml(rename = "MuseHouseholdId", ns(""))]
        pub muse_household_id: Option<String>,
        #[xml(rename = "NetsettingsUpdateID", ns(""))]
        pub netsettings_update_id: Option<String>,
        #[xml(rename = "SourceAreasUpdateID", ns(""))]
        pub source_areas_update_id: Option<String>,
        #[xml(rename = "ThirdPartyMediaServersX", ns(""))]
        pub third_party_media_servers_x: Option<String>,
        #[xml(rename = "ZoneGroupID", ns(""))]
        pub zone_group_id: Option<String>,
        #[xml(rename = "ZoneGroupName", ns(""))]
        pub zone_group_name: Option<String>,
        #[xml(rename = "ZoneGroupState", ns(""))]
        pub zone_group_state: Option<crate::xmlutil::DecodeXmlString<crate::ZoneGroupState>>,
        #[xml(rename = "ZonePlayerUUIDsInGroup", ns(""))]
        pub zone_player_uuids_in_group: Option<String>,
    }

    impl crate::upnp::DecodeXml for ZoneGroupTopologyEvent {
        fn decode_xml(xml: &str) -> crate::Result<Self> {
            let mut result = Self::default();
            let set: ZoneGroupTopologyPropertySet = instant_xml::from_str(xml)?;
            for prop in set.properties {
                if let Some(v) = prop.alarm_run_sequence {
                    result.alarm_run_sequence.replace(v);
                }

                if let Some(v) = prop.areas_update_id {
                    result.areas_update_id.replace(v);
                }

                if let Some(v) = prop.available_software_update {
                    result.available_software_update.replace(v);
                }

                if let Some(v) = prop.muse_household_id {
                    result.muse_household_id.replace(v);
                }

                if let Some(v) = prop.netsettings_update_id {
                    result.netsettings_update_id.replace(v);
                }

                if let Some(v) = prop.source_areas_update_id {
                    result.source_areas_update_id.replace(v);
                }

                if let Some(v) = prop.third_party_media_servers_x {
                    result.third_party_media_servers_x.replace(v);
                }

                if let Some(v) = prop.zone_group_id {
                    result.zone_group_id.replace(v);
                }

                if let Some(v) = prop.zone_group_name {
                    result.zone_group_name.replace(v);
                }

                if let Some(v) = prop.zone_group_state {
                    result.zone_group_state.replace(v);
                }

                if let Some(v) = prop.zone_player_uuids_in_group {
                    result.zone_player_uuids_in_group.replace(v);
                }
            }
            Ok(result)
        }
    }

    impl crate::SonosDevice {
        /// Subscribe to events from the `ZoneGroupTopology` service on this device
        pub async fn subscribe_zone_group_topology(
            &self,
        ) -> crate::Result<crate::upnp::EventStream<ZoneGroupTopologyEvent>> {
            self.subscribe_helper(&SERVICE_TYPE).await
        }
    }
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum UnresponsiveDeviceActionType {
    #[default]
    Remove,
    TopologyMonitorProbe,
    VerifyThenRemoveSystemwide,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for UnresponsiveDeviceActionType {
    fn to_string(&self) -> String {
        match self {
            UnresponsiveDeviceActionType::Remove => "Remove".to_string(),
            UnresponsiveDeviceActionType::TopologyMonitorProbe => {
                "TopologyMonitorProbe".to_string()
            }
            UnresponsiveDeviceActionType::VerifyThenRemoveSystemwide => {
                "VerifyThenRemoveSystemwide".to_string()
            }
            UnresponsiveDeviceActionType::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for UnresponsiveDeviceActionType {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<UnresponsiveDeviceActionType> {
        match s {
            "Remove" => Ok(UnresponsiveDeviceActionType::Remove),
            "TopologyMonitorProbe" => Ok(UnresponsiveDeviceActionType::TopologyMonitorProbe),
            "VerifyThenRemoveSystemwide" => {
                Ok(UnresponsiveDeviceActionType::VerifyThenRemoveSystemwide)
            }
            s => Ok(UnresponsiveDeviceActionType::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for UnresponsiveDeviceActionType {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for UnresponsiveDeviceActionType {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: UnresponsiveDeviceActionType = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<UnresponsiveDeviceActionType>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[derive(PartialEq, Debug, Clone, Eq, Default)]
pub enum UpdateType {
    #[default]
    All,
    Software,

    /// Allows passing a value that was not known at the
    /// time that this crate was generated from the available
    /// device descriptions
    Unspecified(String),
}

impl ToString for UpdateType {
    fn to_string(&self) -> String {
        match self {
            UpdateType::All => "All".to_string(),
            UpdateType::Software => "Software".to_string(),
            UpdateType::Unspecified(s) => s.to_string(),
        }
    }
}

impl FromStr for UpdateType {
    type Err = crate::Error;
    fn from_str(s: &str) -> Result<UpdateType> {
        match s {
            "All" => Ok(UpdateType::All),
            "Software" => Ok(UpdateType::Software),
            s => Ok(UpdateType::Unspecified(s.to_string())),
        }
    }
}

impl instant_xml::ToXml for UpdateType {
    fn serialize<W: std::fmt::Write + ?Sized>(
        &self,
        field: Option<instant_xml::Id<'_>>,
        serializer: &mut instant_xml::Serializer<W>,
    ) -> std::result::Result<(), instant_xml::Error> {
        self.to_string().serialize(field, serializer)
    }

    fn present(&self) -> bool {
        true
    }
}

impl<'xml> instant_xml::FromXml<'xml> for UpdateType {
    #[inline]
    fn matches(id: instant_xml::Id<'_>, field: Option<instant_xml::Id<'_>>) -> bool {
        match field {
            Some(field) => id == field,
            None => false,
        }
    }

    fn deserialize<'cx>(
        into: &mut Self::Accumulator,
        field: &'static str,
        deserializer: &mut instant_xml::Deserializer<'cx, 'xml>,
    ) -> std::result::Result<(), instant_xml::Error> {
        if into.is_some() {
            return Err(instant_xml::Error::DuplicateValue);
        }

        match deserializer.take_str()? {
            Some(value) => {
                let parsed: UpdateType = value.parse().map_err(|err| {
                    instant_xml::Error::Other(format!(
                        "invalid value for field {field}: {value}: {err:#}"
                    ))
                })?;
                *into = Some(parsed);
                Ok(())
            }
            None => Err(instant_xml::Error::MissingValue(field)),
        }
    }

    type Accumulator = Option<UpdateType>;
    const KIND: instant_xml::Kind = instant_xml::Kind::Scalar;
}

#[allow(async_fn_in_trait)]
/// Service that controls stuff related to transport (play/pause/next/special URLs)
pub trait AVTransport {
    async fn add_multiple_uris_to_queue(
        &self,
        request: av_transport::AddMultipleUrisToQueueRequest,
    ) -> Result<av_transport::AddMultipleUrisToQueueResponse>;
    /// Adds songs to the SONOS queue
    async fn add_uri_to_queue(
        &self,
        request: av_transport::AddUriToQueueRequest,
    ) -> Result<av_transport::AddUriToQueueResponse>;
    async fn add_uri_to_saved_queue(
        &self,
        request: av_transport::AddUriToSavedQueueRequest,
    ) -> Result<av_transport::AddUriToSavedQueueResponse>;
    async fn backup_queue(&self, request: av_transport::BackupQueueRequest) -> Result<()>;
    /// Leave the current group and revert to a single player.
    async fn become_coordinator_of_standalone_group(
        &self,
        request: av_transport::BecomeCoordinatorOfStandaloneGroupRequest,
    ) -> Result<av_transport::BecomeCoordinatorOfStandaloneGroupResponse>;
    async fn become_group_coordinator(
        &self,
        request: av_transport::BecomeGroupCoordinatorRequest,
    ) -> Result<()>;
    async fn become_group_coordinator_and_source(
        &self,
        request: av_transport::BecomeGroupCoordinatorAndSourceRequest,
    ) -> Result<()>;
    async fn change_coordinator(
        &self,
        request: av_transport::ChangeCoordinatorRequest,
    ) -> Result<()>;
    async fn change_transport_settings(
        &self,
        request: av_transport::ChangeTransportSettingsRequest,
    ) -> Result<()>;
    /// Stop playing after set sleep timer or cancel
    async fn configure_sleep_timer(
        &self,
        request: av_transport::ConfigureSleepTimerRequest,
    ) -> Result<()>;
    async fn create_saved_queue(
        &self,
        request: av_transport::CreateSavedQueueRequest,
    ) -> Result<av_transport::CreateSavedQueueResponse>;
    /// Delegates the coordinator role to another player in the same group
    async fn delegate_group_coordination_to(
        &self,
        request: av_transport::DelegateGroupCoordinationToRequest,
    ) -> Result<()>;
    async fn end_direct_control_session(
        &self,
        request: av_transport::EndDirectControlSessionRequest,
    ) -> Result<()>;
    /// Get crossfade mode
    async fn get_crossfade_mode(
        &self,
        request: av_transport::GetCrossfadeModeRequest,
    ) -> Result<av_transport::GetCrossfadeModeResponse>;
    /// Get current transport actions such as Set, Stop, Pause, Play, X_DLNA_SeekTime, Next, X_DLNA_SeekTrackNr
    async fn get_current_transport_actions(
        &self,
        request: av_transport::GetCurrentTransportActionsRequest,
    ) -> Result<av_transport::GetCurrentTransportActionsResponse>;
    async fn get_device_capabilities(
        &self,
        request: av_transport::GetDeviceCapabilitiesRequest,
    ) -> Result<av_transport::GetDeviceCapabilitiesResponse>;
    /// Get information about the current playing media (queue)
    async fn get_media_info(
        &self,
        request: av_transport::GetMediaInfoRequest,
    ) -> Result<av_transport::GetMediaInfoResponse>;
    /// Get information about current position (position in queue and time in current song)
    async fn get_position_info(
        &self,
        request: av_transport::GetPositionInfoRequest,
    ) -> Result<av_transport::GetPositionInfoResponse>;
    /// Get time left on sleeptimer.
    async fn get_remaining_sleep_timer_duration(
        &self,
        request: av_transport::GetRemainingSleepTimerDurationRequest,
    ) -> Result<av_transport::GetRemainingSleepTimerDurationResponse>;
    async fn get_running_alarm_properties(
        &self,
        request: av_transport::GetRunningAlarmPropertiesRequest,
    ) -> Result<av_transport::GetRunningAlarmPropertiesResponse>;
    /// Get current transport status, speed and state such as PLAYING, STOPPED, PLAYING, PAUSED_PLAYBACK, TRANSITIONING, NO_MEDIA_PRESENT
    async fn get_transport_info(
        &self,
        request: av_transport::GetTransportInfoRequest,
    ) -> Result<av_transport::GetTransportInfoResponse>;
    /// Get transport settings
    async fn get_transport_settings(
        &self,
        request: av_transport::GetTransportSettingsRequest,
    ) -> Result<av_transport::GetTransportSettingsResponse>;
    /// Go to next song
    async fn next(&self, request: av_transport::NextRequest) -> Result<()>;
    async fn notify_deleted_uri(
        &self,
        request: av_transport::NotifyDeletedUriRequest,
    ) -> Result<()>;
    /// Pause playback
    async fn pause(&self, request: av_transport::PauseRequest) -> Result<()>;
    /// Start playing the set TransportURI
    async fn play(&self, request: av_transport::PlayRequest) -> Result<()>;
    /// Go to previous song
    async fn previous(&self, request: av_transport::PreviousRequest) -> Result<()>;
    /// Flushes the SONOS queue.
    async fn remove_all_tracks_from_queue(
        &self,
        request: av_transport::RemoveAllTracksFromQueueRequest,
    ) -> Result<()>;
    async fn remove_track_from_queue(
        &self,
        request: av_transport::RemoveTrackFromQueueRequest,
    ) -> Result<()>;
    /// Removes the specified range of songs from the SONOS queue.
    async fn remove_track_range_from_queue(
        &self,
        request: av_transport::RemoveTrackRangeFromQueueRequest,
    ) -> Result<av_transport::RemoveTrackRangeFromQueueResponse>;
    async fn reorder_tracks_in_queue(
        &self,
        request: av_transport::ReorderTracksInQueueRequest,
    ) -> Result<()>;
    async fn reorder_tracks_in_saved_queue(
        &self,
        request: av_transport::ReorderTracksInSavedQueueRequest,
    ) -> Result<av_transport::ReorderTracksInSavedQueueResponse>;
    async fn run_alarm(&self, request: av_transport::RunAlarmRequest) -> Result<()>;
    /// Saves the current SONOS queue as a SONOS playlist and outputs objectID
    async fn save_queue(
        &self,
        request: av_transport::SaveQueueRequest,
    ) -> Result<av_transport::SaveQueueResponse>;
    /// Seek track in queue, time delta or absolute time in song
    async fn seek(&self, request: av_transport::SeekRequest) -> Result<()>;
    /// Set the transport URI to a song, a stream, the queue, another player-rincon and a lot more
    async fn set_av_transport_uri(
        &self,
        request: av_transport::SetAvTransportUriRequest,
    ) -> Result<()>;
    /// Set crossfade mode
    async fn set_crossfade_mode(
        &self,
        request: av_transport::SetCrossfadeModeRequest,
    ) -> Result<()>;
    async fn set_next_av_transport_uri(
        &self,
        request: av_transport::SetNextAvTransportUriRequest,
    ) -> Result<()>;
    /// Set the PlayMode
    async fn set_play_mode(&self, request: av_transport::SetPlayModeRequest) -> Result<()>;
    /// Snooze the current alarm for some time.
    async fn snooze_alarm(&self, request: av_transport::SnoozeAlarmRequest) -> Result<()>;
    async fn start_autoplay(&self, request: av_transport::StartAutoplayRequest) -> Result<()>;
    /// Stop playback
    async fn stop(&self, request: av_transport::StopRequest) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Control the sonos alarms and times
pub trait AlarmClock {
    /// Create a single alarm, all properties are required
    async fn create_alarm(
        &self,
        request: alarm_clock::CreateAlarmRequest,
    ) -> Result<alarm_clock::CreateAlarmResponse>;
    /// Delete an alarm
    async fn destroy_alarm(&self, request: alarm_clock::DestroyAlarmRequest) -> Result<()>;
    async fn get_daily_index_refresh_time(
        &self,
    ) -> Result<alarm_clock::GetDailyIndexRefreshTimeResponse>;
    async fn get_format(&self) -> Result<alarm_clock::GetFormatResponse>;
    async fn get_household_time_at_stamp(
        &self,
        request: alarm_clock::GetHouseholdTimeAtStampRequest,
    ) -> Result<alarm_clock::GetHouseholdTimeAtStampResponse>;
    async fn get_time_now(&self) -> Result<alarm_clock::GetTimeNowResponse>;
    async fn get_time_server(&self) -> Result<alarm_clock::GetTimeServerResponse>;
    async fn get_time_zone(&self) -> Result<alarm_clock::GetTimeZoneResponse>;
    async fn get_time_zone_and_rule(&self) -> Result<alarm_clock::GetTimeZoneAndRuleResponse>;
    async fn get_time_zone_rule(
        &self,
        request: alarm_clock::GetTimeZoneRuleRequest,
    ) -> Result<alarm_clock::GetTimeZoneRuleResponse>;
    /// Get the AlarmList as XML
    async fn list_alarms(&self) -> Result<alarm_clock::ListAlarmsResponse>;
    async fn set_daily_index_refresh_time(
        &self,
        request: alarm_clock::SetDailyIndexRefreshTimeRequest,
    ) -> Result<()>;
    async fn set_format(&self, request: alarm_clock::SetFormatRequest) -> Result<()>;
    async fn set_time_now(&self, request: alarm_clock::SetTimeNowRequest) -> Result<()>;
    async fn set_time_server(&self, request: alarm_clock::SetTimeServerRequest) -> Result<()>;
    async fn set_time_zone(&self, request: alarm_clock::SetTimeZoneRequest) -> Result<()>;
    /// Update an alarm, all parameters are required.
    async fn update_alarm(&self, request: alarm_clock::UpdateAlarmRequest) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Control line in
pub trait AudioIn {
    async fn get_audio_input_attributes(&self)
        -> Result<audio_in::GetAudioInputAttributesResponse>;
    async fn get_line_in_level(&self) -> Result<audio_in::GetLineInLevelResponse>;
    async fn select_audio(&self, request: audio_in::SelectAudioRequest) -> Result<()>;
    async fn set_audio_input_attributes(
        &self,
        request: audio_in::SetAudioInputAttributesRequest,
    ) -> Result<()>;
    async fn set_line_in_level(&self, request: audio_in::SetLineInLevelRequest) -> Result<()>;
    async fn start_transmission_to_group(
        &self,
        request: audio_in::StartTransmissionToGroupRequest,
    ) -> Result<audio_in::StartTransmissionToGroupResponse>;
    async fn stop_transmission_to_group(
        &self,
        request: audio_in::StopTransmissionToGroupRequest,
    ) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Services related to connections and protocols
pub trait ConnectionManager {
    async fn get_current_connection_ids(
        &self,
    ) -> Result<connection_manager::GetCurrentConnectionIdsResponse>;
    async fn get_current_connection_info(
        &self,
        request: connection_manager::GetCurrentConnectionInfoRequest,
    ) -> Result<connection_manager::GetCurrentConnectionInfoResponse>;
    async fn get_protocol_info(&self) -> Result<connection_manager::GetProtocolInfoResponse>;
}

#[allow(async_fn_in_trait)]
/// Browse for local content
pub trait ContentDirectory {
    /// Browse for content: Music library (A), share(S:), Sonos playlists(SQ:), Sonos favorites(FV:2), radio stations(R:0/0), radio shows(R:0/1), queue(Q:)). Recommendation: Send one request, check the `TotalMatches` and - if necessary - do additional requests with higher `StartingIndex`. In case of duplicates only the first is returned! Example: albums with same title, even if artists are different
    async fn browse(
        &self,
        request: content_directory::BrowseRequest,
    ) -> Result<content_directory::BrowseResponse>;
    async fn create_object(
        &self,
        request: content_directory::CreateObjectRequest,
    ) -> Result<content_directory::CreateObjectResponse>;
    async fn destroy_object(&self, request: content_directory::DestroyObjectRequest) -> Result<()>;
    async fn find_prefix(
        &self,
        request: content_directory::FindPrefixRequest,
    ) -> Result<content_directory::FindPrefixResponse>;
    /// Get the current album art display option such as `WMP`, `ITUNES` or `NONE`
    async fn get_album_artist_display_option(
        &self,
    ) -> Result<content_directory::GetAlbumArtistDisplayOptionResponse>;
    async fn get_all_prefix_locations(
        &self,
        request: content_directory::GetAllPrefixLocationsRequest,
    ) -> Result<content_directory::GetAllPrefixLocationsResponse>;
    async fn get_browseable(&self) -> Result<content_directory::GetBrowseableResponse>;
    async fn get_last_index_change(&self) -> Result<content_directory::GetLastIndexChangeResponse>;
    async fn get_search_capabilities(
        &self,
    ) -> Result<content_directory::GetSearchCapabilitiesResponse>;
    async fn get_share_index_in_progress(
        &self,
    ) -> Result<content_directory::GetShareIndexInProgressResponse>;
    async fn get_sort_capabilities(&self)
        -> Result<content_directory::GetSortCapabilitiesResponse>;
    async fn get_system_update_id(&self) -> Result<content_directory::GetSystemUpdateIdResponse>;
    /// Updates the music library (share) index
    async fn refresh_share_index(
        &self,
        request: content_directory::RefreshShareIndexRequest,
    ) -> Result<()>;
    async fn request_resort(&self, request: content_directory::RequestResortRequest) -> Result<()>;
    async fn set_browseable(&self, request: content_directory::SetBrowseableRequest) -> Result<()>;
    async fn update_object(&self, request: content_directory::UpdateObjectRequest) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Modify device properties, like LED status and stereo pairs
pub trait DeviceProperties {
    async fn add_bonded_zones(
        &self,
        request: device_properties::AddBondedZonesRequest,
    ) -> Result<()>;
    /// Adds satellites and/or a sub woofer to a (main) player. The satellites become hidden. The main player RINCON_* is mandatory. RR: right - rear, LF: left - front, SW: subwoofer
    async fn add_ht_satellite(
        &self,
        request: device_properties::AddHtSatelliteRequest,
    ) -> Result<()>;
    /// Create a stereo pair (left, right speakers), right one becomes hidden
    async fn create_stereo_pair(
        &self,
        request: device_properties::CreateStereoPairRequest,
    ) -> Result<()>;
    async fn enter_config_mode(
        &self,
        request: device_properties::EnterConfigModeRequest,
    ) -> Result<device_properties::EnterConfigModeResponse>;
    async fn exit_config_mode(
        &self,
        request: device_properties::ExitConfigModeRequest,
    ) -> Result<()>;
    async fn get_autoplay_linked_zones(
        &self,
        request: device_properties::GetAutoplayLinkedZonesRequest,
    ) -> Result<device_properties::GetAutoplayLinkedZonesResponse>;
    async fn get_autoplay_room_uuid(
        &self,
        request: device_properties::GetAutoplayRoomUuidRequest,
    ) -> Result<device_properties::GetAutoplayRoomUuidResponse>;
    async fn get_autoplay_volume(
        &self,
        request: device_properties::GetAutoplayVolumeRequest,
    ) -> Result<device_properties::GetAutoplayVolumeResponse>;
    /// Get the current button lock state
    async fn get_button_lock_state(&self) -> Result<device_properties::GetButtonLockStateResponse>;
    async fn get_button_state(&self) -> Result<device_properties::GetButtonStateResponse>;
    async fn get_ht_forward_state(&self) -> Result<device_properties::GetHtForwardStateResponse>;
    async fn get_household_id(&self) -> Result<device_properties::GetHouseholdIdResponse>;
    /// Get the current LED state
    async fn get_led_state(&self) -> Result<device_properties::GetLedStateResponse>;
    async fn get_use_autoplay_volume(
        &self,
        request: device_properties::GetUseAutoplayVolumeRequest,
    ) -> Result<device_properties::GetUseAutoplayVolumeResponse>;
    async fn get_zone_attributes(&self) -> Result<device_properties::GetZoneAttributesResponse>;
    /// Get information about this specific speaker
    async fn get_zone_info(&self) -> Result<device_properties::GetZoneInfoResponse>;
    async fn remove_bonded_zones(
        &self,
        request: device_properties::RemoveBondedZonesRequest,
    ) -> Result<()>;
    /// Removes a satellite or a sub woofer from (main) player. The satellite becomes visible.
    async fn remove_ht_satellite(
        &self,
        request: device_properties::RemoveHtSatelliteRequest,
    ) -> Result<()>;
    async fn room_detection_start_chirping(
        &self,
        request: device_properties::RoomDetectionStartChirpingRequest,
    ) -> Result<device_properties::RoomDetectionStartChirpingResponse>;
    async fn room_detection_stop_chirping(
        &self,
        request: device_properties::RoomDetectionStopChirpingRequest,
    ) -> Result<()>;
    /// Separate a stereo pair
    async fn separate_stereo_pair(
        &self,
        request: device_properties::SeparateStereoPairRequest,
    ) -> Result<()>;
    async fn set_autoplay_linked_zones(
        &self,
        request: device_properties::SetAutoplayLinkedZonesRequest,
    ) -> Result<()>;
    async fn set_autoplay_room_uuid(
        &self,
        request: device_properties::SetAutoplayRoomUuidRequest,
    ) -> Result<()>;
    async fn set_autoplay_volume(
        &self,
        request: device_properties::SetAutoplayVolumeRequest,
    ) -> Result<()>;
    /// Set the button lock state
    async fn set_button_lock_state(
        &self,
        request: device_properties::SetButtonLockStateRequest,
    ) -> Result<()>;
    /// Set the LED state
    async fn set_led_state(&self, request: device_properties::SetLedStateRequest) -> Result<()>;
    async fn set_use_autoplay_volume(
        &self,
        request: device_properties::SetUseAutoplayVolumeRequest,
    ) -> Result<()>;
    async fn set_zone_attributes(
        &self,
        request: device_properties::SetZoneAttributesRequest,
    ) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Services related to groups
pub trait GroupManagement {
    async fn add_member(
        &self,
        request: group_management::AddMemberRequest,
    ) -> Result<group_management::AddMemberResponse>;
    async fn remove_member(&self, request: group_management::RemoveMemberRequest) -> Result<()>;
    async fn report_track_buffering_result(
        &self,
        request: group_management::ReportTrackBufferingResultRequest,
    ) -> Result<()>;
    async fn set_source_area_ids(
        &self,
        request: group_management::SetSourceAreaIdsRequest,
    ) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Volume related controls for groups
pub trait GroupRenderingControl {
    /// Get the group mute state.
    async fn get_group_mute(
        &self,
        request: group_rendering_control::GetGroupMuteRequest,
    ) -> Result<group_rendering_control::GetGroupMuteResponse>;
    /// Get the group volume.
    async fn get_group_volume(
        &self,
        request: group_rendering_control::GetGroupVolumeRequest,
    ) -> Result<group_rendering_control::GetGroupVolumeResponse>;
    /// (Un-/)Mute the entire group
    async fn set_group_mute(
        &self,
        request: group_rendering_control::SetGroupMuteRequest,
    ) -> Result<()>;
    /// Change group volume. Players volume will be changed proportionally based on last snapshot
    async fn set_group_volume(
        &self,
        request: group_rendering_control::SetGroupVolumeRequest,
    ) -> Result<()>;
    /// Relatively change group volume - returns final group volume. Players volume will be changed proportionally based on last snapshot
    async fn set_relative_group_volume(
        &self,
        request: group_rendering_control::SetRelativeGroupVolumeRequest,
    ) -> Result<group_rendering_control::SetRelativeGroupVolumeResponse>;
    /// Creates a new group volume snapshot,  the volume ratio between all players. It is used by SetGroupVolume and SetRelativeGroupVolume
    async fn snapshot_group_volume(
        &self,
        request: group_rendering_control::SnapshotGroupVolumeRequest,
    ) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Service related to the TV remote control
pub trait HTControl {
    async fn commit_learned_ir_codes(
        &self,
        request: ht_control::CommitLearnedIrCodesRequest,
    ) -> Result<()>;
    async fn get_ir_repeater_state(&self) -> Result<ht_control::GetIrRepeaterStateResponse>;
    async fn get_led_feedback_state(&self) -> Result<ht_control::GetLedFeedbackStateResponse>;
    async fn identify_ir_remote(&self, request: ht_control::IdentifyIrRemoteRequest) -> Result<()>;
    async fn is_remote_configured(&self) -> Result<ht_control::IsRemoteConfiguredResponse>;
    async fn learn_ir_code(&self, request: ht_control::LearnIrCodeRequest) -> Result<()>;
    async fn set_ir_repeater_state(
        &self,
        request: ht_control::SetIrRepeaterStateRequest,
    ) -> Result<()>;
    async fn set_led_feedback_state(
        &self,
        request: ht_control::SetLedFeedbackStateRequest,
    ) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Access to external music services, like Spotify or Youtube Music
pub trait MusicServices {
    async fn get_session_id(
        &self,
        request: music_services::GetSessionIdRequest,
    ) -> Result<music_services::GetSessionIdResponse>;
    /// Load music service list as xml
    async fn list_available_services(
        &self,
    ) -> Result<music_services::ListAvailableServicesResponse>;
    async fn update_available_services(&self) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Services related to Chinese Tencent Qplay service
pub trait QPlay {
    async fn q_play_auth(
        &self,
        request: q_play::QPlayAuthRequest,
    ) -> Result<q_play::QPlayAuthResponse>;
}

#[allow(async_fn_in_trait)]
/// Modify and browse queues
pub trait Queue {
    async fn add_multiple_uris(
        &self,
        request: queue::AddMultipleUrisRequest,
    ) -> Result<queue::AddMultipleUrisResponse>;
    async fn add_uri(&self, request: queue::AddUriRequest) -> Result<queue::AddUriResponse>;
    async fn attach_queue(
        &self,
        request: queue::AttachQueueRequest,
    ) -> Result<queue::AttachQueueResponse>;
    async fn backup(&self) -> Result<()>;
    async fn browse(&self, request: queue::BrowseRequest) -> Result<queue::BrowseResponse>;
    async fn create_queue(
        &self,
        request: queue::CreateQueueRequest,
    ) -> Result<queue::CreateQueueResponse>;
    async fn remove_all_tracks(
        &self,
        request: queue::RemoveAllTracksRequest,
    ) -> Result<queue::RemoveAllTracksResponse>;
    async fn remove_track_range(
        &self,
        request: queue::RemoveTrackRangeRequest,
    ) -> Result<queue::RemoveTrackRangeResponse>;
    async fn reorder_tracks(
        &self,
        request: queue::ReorderTracksRequest,
    ) -> Result<queue::ReorderTracksResponse>;
    async fn replace_all_tracks(
        &self,
        request: queue::ReplaceAllTracksRequest,
    ) -> Result<queue::ReplaceAllTracksResponse>;
    async fn save_as_sonos_playlist(
        &self,
        request: queue::SaveAsSonosPlaylistRequest,
    ) -> Result<queue::SaveAsSonosPlaylistResponse>;
}

#[allow(async_fn_in_trait)]
/// Volume related controls
pub trait RenderingControl {
    /// Get bass level between -10 and 10
    async fn get_bass(
        &self,
        request: rendering_control::GetBassRequest,
    ) -> Result<rendering_control::GetBassResponse>;
    /// Get equalizer value
    async fn get_eq(
        &self,
        request: rendering_control::GetEqRequest,
    ) -> Result<rendering_control::GetEqResponse>;
    async fn get_headphone_connected(
        &self,
        request: rendering_control::GetHeadphoneConnectedRequest,
    ) -> Result<rendering_control::GetHeadphoneConnectedResponse>;
    /// Whether or not Loudness is on
    async fn get_loudness(
        &self,
        request: rendering_control::GetLoudnessRequest,
    ) -> Result<rendering_control::GetLoudnessResponse>;
    async fn get_mute(
        &self,
        request: rendering_control::GetMuteRequest,
    ) -> Result<rendering_control::GetMuteResponse>;
    async fn get_output_fixed(
        &self,
        request: rendering_control::GetOutputFixedRequest,
    ) -> Result<rendering_control::GetOutputFixedResponse>;
    async fn get_room_calibration_status(
        &self,
        request: rendering_control::GetRoomCalibrationStatusRequest,
    ) -> Result<rendering_control::GetRoomCalibrationStatusResponse>;
    async fn get_supports_output_fixed(
        &self,
        request: rendering_control::GetSupportsOutputFixedRequest,
    ) -> Result<rendering_control::GetSupportsOutputFixedResponse>;
    /// Get treble
    async fn get_treble(
        &self,
        request: rendering_control::GetTrebleRequest,
    ) -> Result<rendering_control::GetTrebleResponse>;
    /// Get volume
    async fn get_volume(
        &self,
        request: rendering_control::GetVolumeRequest,
    ) -> Result<rendering_control::GetVolumeResponse>;
    async fn get_volume_db(
        &self,
        request: rendering_control::GetVolumeDbRequest,
    ) -> Result<rendering_control::GetVolumeDbResponse>;
    async fn get_volume_db_range(
        &self,
        request: rendering_control::GetVolumeDbRangeRequest,
    ) -> Result<rendering_control::GetVolumeDbRangeResponse>;
    async fn ramp_to_volume(
        &self,
        request: rendering_control::RampToVolumeRequest,
    ) -> Result<rendering_control::RampToVolumeResponse>;
    async fn reset_basic_eq(
        &self,
        request: rendering_control::ResetBasicEqRequest,
    ) -> Result<rendering_control::ResetBasicEqResponse>;
    async fn reset_ext_eq(&self, request: rendering_control::ResetExtEqRequest) -> Result<()>;
    async fn restore_volume_prior_to_ramp(
        &self,
        request: rendering_control::RestoreVolumePriorToRampRequest,
    ) -> Result<()>;
    /// Set bass level, between -10 and 10
    async fn set_bass(&self, request: rendering_control::SetBassRequest) -> Result<()>;
    async fn set_channel_map(&self, request: rendering_control::SetChannelMapRequest)
        -> Result<()>;
    /// Set equalizer value for different types
    async fn set_eq(&self, request: rendering_control::SetEqRequest) -> Result<()>;
    /// Set loudness on / off
    async fn set_loudness(&self, request: rendering_control::SetLoudnessRequest) -> Result<()>;
    async fn set_mute(&self, request: rendering_control::SetMuteRequest) -> Result<()>;
    async fn set_output_fixed(
        &self,
        request: rendering_control::SetOutputFixedRequest,
    ) -> Result<()>;
    async fn set_relative_volume(
        &self,
        request: rendering_control::SetRelativeVolumeRequest,
    ) -> Result<rendering_control::SetRelativeVolumeResponse>;
    async fn set_room_calibration_status(
        &self,
        request: rendering_control::SetRoomCalibrationStatusRequest,
    ) -> Result<()>;
    async fn set_room_calibration_x(
        &self,
        request: rendering_control::SetRoomCalibrationXRequest,
    ) -> Result<()>;
    /// Set treble level
    async fn set_treble(&self, request: rendering_control::SetTrebleRequest) -> Result<()>;
    async fn set_volume(&self, request: rendering_control::SetVolumeRequest) -> Result<()>;
    async fn set_volume_db(&self, request: rendering_control::SetVolumeDbRequest) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Manage system-wide settings, mainly account stuff
pub trait SystemProperties {
    async fn add_account_x(
        &self,
        request: system_properties::AddAccountXRequest,
    ) -> Result<system_properties::AddAccountXResponse>;
    async fn add_o_auth_account_x(
        &self,
        request: system_properties::AddOAuthAccountXRequest,
    ) -> Result<system_properties::AddOAuthAccountXResponse>;
    async fn do_post_update_tasks(&self) -> Result<()>;
    async fn edit_account_md(&self, request: system_properties::EditAccountMdRequest)
        -> Result<()>;
    async fn edit_account_password_x(
        &self,
        request: system_properties::EditAccountPasswordXRequest,
    ) -> Result<()>;
    async fn enable_rdm(&self, request: system_properties::EnableRdmRequest) -> Result<()>;
    async fn get_rdm(&self) -> Result<system_properties::GetRdmResponse>;
    /// Get a saved string.
    async fn get_string(
        &self,
        request: system_properties::GetStringRequest,
    ) -> Result<system_properties::GetStringResponse>;
    async fn get_web_code(
        &self,
        request: system_properties::GetWebCodeRequest,
    ) -> Result<system_properties::GetWebCodeResponse>;
    async fn provision_credentialed_trial_account_x(
        &self,
        request: system_properties::ProvisionCredentialedTrialAccountXRequest,
    ) -> Result<system_properties::ProvisionCredentialedTrialAccountXResponse>;
    async fn refresh_account_credentials_x(
        &self,
        request: system_properties::RefreshAccountCredentialsXRequest,
    ) -> Result<()>;
    /// Remove a saved string
    async fn remove(&self, request: system_properties::RemoveRequest) -> Result<()>;
    async fn remove_account(&self, request: system_properties::RemoveAccountRequest) -> Result<()>;
    async fn replace_account_x(
        &self,
        request: system_properties::ReplaceAccountXRequest,
    ) -> Result<system_properties::ReplaceAccountXResponse>;
    async fn reset_third_party_credentials(&self) -> Result<()>;
    async fn set_account_nickname_x(
        &self,
        request: system_properties::SetAccountNicknameXRequest,
    ) -> Result<()>;
    /// Save a string in the system
    async fn set_string(&self, request: system_properties::SetStringRequest) -> Result<()>;
}

#[allow(async_fn_in_trait)]
pub trait VirtualLineIn {
    async fn next(&self, request: virtual_line_in::NextRequest) -> Result<()>;
    async fn pause(&self, request: virtual_line_in::PauseRequest) -> Result<()>;
    async fn play(&self, request: virtual_line_in::PlayRequest) -> Result<()>;
    async fn previous(&self, request: virtual_line_in::PreviousRequest) -> Result<()>;
    async fn set_volume(&self, request: virtual_line_in::SetVolumeRequest) -> Result<()>;
    async fn start_transmission(
        &self,
        request: virtual_line_in::StartTransmissionRequest,
    ) -> Result<virtual_line_in::StartTransmissionResponse>;
    async fn stop(&self, request: virtual_line_in::StopRequest) -> Result<()>;
    async fn stop_transmission(
        &self,
        request: virtual_line_in::StopTransmissionRequest,
    ) -> Result<()>;
}

#[allow(async_fn_in_trait)]
/// Zone config stuff, eg getting all the configured sonos zones
pub trait ZoneGroupTopology {
    async fn begin_software_update(
        &self,
        request: zone_group_topology::BeginSoftwareUpdateRequest,
    ) -> Result<()>;
    async fn check_for_update(
        &self,
        request: zone_group_topology::CheckForUpdateRequest,
    ) -> Result<zone_group_topology::CheckForUpdateResponse>;
    /// Get information about the current Zone
    async fn get_zone_group_attributes(
        &self,
    ) -> Result<zone_group_topology::GetZoneGroupAttributesResponse>;
    /// Get all the Sonos groups, (as XML)
    async fn get_zone_group_state(&self) -> Result<zone_group_topology::GetZoneGroupStateResponse>;
    async fn register_mobile_device(
        &self,
        request: zone_group_topology::RegisterMobileDeviceRequest,
    ) -> Result<()>;
    async fn report_alarm_started_running(&self) -> Result<()>;
    async fn report_unresponsive_device(
        &self,
        request: zone_group_topology::ReportUnresponsiveDeviceRequest,
    ) -> Result<()>;
    async fn submit_diagnostics(
        &self,
        request: zone_group_topology::SubmitDiagnosticsRequest,
    ) -> Result<zone_group_topology::SubmitDiagnosticsResponse>;
}

impl AVTransport for SonosDevice {
    async fn add_multiple_uris_to_queue(
        &self,
        request: av_transport::AddMultipleUrisToQueueRequest,
    ) -> Result<av_transport::AddMultipleUrisToQueueResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "AddMultipleURIsToQueue",
            request,
        )
        .await
    }

    async fn add_uri_to_queue(
        &self,
        request: av_transport::AddUriToQueueRequest,
    ) -> Result<av_transport::AddUriToQueueResponse> {
        self.action(&av_transport::SERVICE_TYPE, "AddURIToQueue", request)
            .await
    }

    async fn add_uri_to_saved_queue(
        &self,
        request: av_transport::AddUriToSavedQueueRequest,
    ) -> Result<av_transport::AddUriToSavedQueueResponse> {
        self.action(&av_transport::SERVICE_TYPE, "AddURIToSavedQueue", request)
            .await
    }

    async fn backup_queue(&self, request: av_transport::BackupQueueRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "BackupQueue", request)
            .await
    }

    async fn become_coordinator_of_standalone_group(
        &self,
        request: av_transport::BecomeCoordinatorOfStandaloneGroupRequest,
    ) -> Result<av_transport::BecomeCoordinatorOfStandaloneGroupResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "BecomeCoordinatorOfStandaloneGroup",
            request,
        )
        .await
    }

    async fn become_group_coordinator(
        &self,
        request: av_transport::BecomeGroupCoordinatorRequest,
    ) -> Result<()> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "BecomeGroupCoordinator",
            request,
        )
        .await
    }

    async fn become_group_coordinator_and_source(
        &self,
        request: av_transport::BecomeGroupCoordinatorAndSourceRequest,
    ) -> Result<()> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "BecomeGroupCoordinatorAndSource",
            request,
        )
        .await
    }

    async fn change_coordinator(
        &self,
        request: av_transport::ChangeCoordinatorRequest,
    ) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "ChangeCoordinator", request)
            .await
    }

    async fn change_transport_settings(
        &self,
        request: av_transport::ChangeTransportSettingsRequest,
    ) -> Result<()> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "ChangeTransportSettings",
            request,
        )
        .await
    }

    async fn configure_sleep_timer(
        &self,
        request: av_transport::ConfigureSleepTimerRequest,
    ) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "ConfigureSleepTimer", request)
            .await
    }

    async fn create_saved_queue(
        &self,
        request: av_transport::CreateSavedQueueRequest,
    ) -> Result<av_transport::CreateSavedQueueResponse> {
        self.action(&av_transport::SERVICE_TYPE, "CreateSavedQueue", request)
            .await
    }

    async fn delegate_group_coordination_to(
        &self,
        request: av_transport::DelegateGroupCoordinationToRequest,
    ) -> Result<()> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "DelegateGroupCoordinationTo",
            request,
        )
        .await
    }

    async fn end_direct_control_session(
        &self,
        request: av_transport::EndDirectControlSessionRequest,
    ) -> Result<()> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "EndDirectControlSession",
            request,
        )
        .await
    }

    async fn get_crossfade_mode(
        &self,
        request: av_transport::GetCrossfadeModeRequest,
    ) -> Result<av_transport::GetCrossfadeModeResponse> {
        self.action(&av_transport::SERVICE_TYPE, "GetCrossfadeMode", request)
            .await
    }

    async fn get_current_transport_actions(
        &self,
        request: av_transport::GetCurrentTransportActionsRequest,
    ) -> Result<av_transport::GetCurrentTransportActionsResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "GetCurrentTransportActions",
            request,
        )
        .await
    }

    async fn get_device_capabilities(
        &self,
        request: av_transport::GetDeviceCapabilitiesRequest,
    ) -> Result<av_transport::GetDeviceCapabilitiesResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "GetDeviceCapabilities",
            request,
        )
        .await
    }

    async fn get_media_info(
        &self,
        request: av_transport::GetMediaInfoRequest,
    ) -> Result<av_transport::GetMediaInfoResponse> {
        self.action(&av_transport::SERVICE_TYPE, "GetMediaInfo", request)
            .await
    }

    async fn get_position_info(
        &self,
        request: av_transport::GetPositionInfoRequest,
    ) -> Result<av_transport::GetPositionInfoResponse> {
        self.action(&av_transport::SERVICE_TYPE, "GetPositionInfo", request)
            .await
    }

    async fn get_remaining_sleep_timer_duration(
        &self,
        request: av_transport::GetRemainingSleepTimerDurationRequest,
    ) -> Result<av_transport::GetRemainingSleepTimerDurationResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "GetRemainingSleepTimerDuration",
            request,
        )
        .await
    }

    async fn get_running_alarm_properties(
        &self,
        request: av_transport::GetRunningAlarmPropertiesRequest,
    ) -> Result<av_transport::GetRunningAlarmPropertiesResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "GetRunningAlarmProperties",
            request,
        )
        .await
    }

    async fn get_transport_info(
        &self,
        request: av_transport::GetTransportInfoRequest,
    ) -> Result<av_transport::GetTransportInfoResponse> {
        self.action(&av_transport::SERVICE_TYPE, "GetTransportInfo", request)
            .await
    }

    async fn get_transport_settings(
        &self,
        request: av_transport::GetTransportSettingsRequest,
    ) -> Result<av_transport::GetTransportSettingsResponse> {
        self.action(&av_transport::SERVICE_TYPE, "GetTransportSettings", request)
            .await
    }

    async fn next(&self, request: av_transport::NextRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "Next", request)
            .await
    }

    async fn notify_deleted_uri(
        &self,
        request: av_transport::NotifyDeletedUriRequest,
    ) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "NotifyDeletedURI", request)
            .await
    }

    async fn pause(&self, request: av_transport::PauseRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "Pause", request)
            .await
    }

    async fn play(&self, request: av_transport::PlayRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "Play", request)
            .await
    }

    async fn previous(&self, request: av_transport::PreviousRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "Previous", request)
            .await
    }

    async fn remove_all_tracks_from_queue(
        &self,
        request: av_transport::RemoveAllTracksFromQueueRequest,
    ) -> Result<()> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "RemoveAllTracksFromQueue",
            request,
        )
        .await
    }

    async fn remove_track_from_queue(
        &self,
        request: av_transport::RemoveTrackFromQueueRequest,
    ) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "RemoveTrackFromQueue", request)
            .await
    }

    async fn remove_track_range_from_queue(
        &self,
        request: av_transport::RemoveTrackRangeFromQueueRequest,
    ) -> Result<av_transport::RemoveTrackRangeFromQueueResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "RemoveTrackRangeFromQueue",
            request,
        )
        .await
    }

    async fn reorder_tracks_in_queue(
        &self,
        request: av_transport::ReorderTracksInQueueRequest,
    ) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "ReorderTracksInQueue", request)
            .await
    }

    async fn reorder_tracks_in_saved_queue(
        &self,
        request: av_transport::ReorderTracksInSavedQueueRequest,
    ) -> Result<av_transport::ReorderTracksInSavedQueueResponse> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "ReorderTracksInSavedQueue",
            request,
        )
        .await
    }

    async fn run_alarm(&self, request: av_transport::RunAlarmRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "RunAlarm", request)
            .await
    }

    async fn save_queue(
        &self,
        request: av_transport::SaveQueueRequest,
    ) -> Result<av_transport::SaveQueueResponse> {
        self.action(&av_transport::SERVICE_TYPE, "SaveQueue", request)
            .await
    }

    async fn seek(&self, request: av_transport::SeekRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "Seek", request)
            .await
    }

    async fn set_av_transport_uri(
        &self,
        request: av_transport::SetAvTransportUriRequest,
    ) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "SetAVTransportURI", request)
            .await
    }

    async fn set_crossfade_mode(
        &self,
        request: av_transport::SetCrossfadeModeRequest,
    ) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "SetCrossfadeMode", request)
            .await
    }

    async fn set_next_av_transport_uri(
        &self,
        request: av_transport::SetNextAvTransportUriRequest,
    ) -> Result<()> {
        self.action(
            &av_transport::SERVICE_TYPE,
            "SetNextAVTransportURI",
            request,
        )
        .await
    }

    async fn set_play_mode(&self, request: av_transport::SetPlayModeRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "SetPlayMode", request)
            .await
    }

    async fn snooze_alarm(&self, request: av_transport::SnoozeAlarmRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "SnoozeAlarm", request)
            .await
    }

    async fn start_autoplay(&self, request: av_transport::StartAutoplayRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "StartAutoplay", request)
            .await
    }

    async fn stop(&self, request: av_transport::StopRequest) -> Result<()> {
        self.action(&av_transport::SERVICE_TYPE, "Stop", request)
            .await
    }
}

impl AlarmClock for SonosDevice {
    async fn create_alarm(
        &self,
        request: alarm_clock::CreateAlarmRequest,
    ) -> Result<alarm_clock::CreateAlarmResponse> {
        self.action(&alarm_clock::SERVICE_TYPE, "CreateAlarm", request)
            .await
    }

    async fn destroy_alarm(&self, request: alarm_clock::DestroyAlarmRequest) -> Result<()> {
        self.action(&alarm_clock::SERVICE_TYPE, "DestroyAlarm", request)
            .await
    }

    async fn get_daily_index_refresh_time(
        &self,
    ) -> Result<alarm_clock::GetDailyIndexRefreshTimeResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "GetDailyIndexRefreshTime",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_format(&self) -> Result<alarm_clock::GetFormatResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "GetFormat",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_household_time_at_stamp(
        &self,
        request: alarm_clock::GetHouseholdTimeAtStampRequest,
    ) -> Result<alarm_clock::GetHouseholdTimeAtStampResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "GetHouseholdTimeAtStamp",
            request,
        )
        .await
    }

    async fn get_time_now(&self) -> Result<alarm_clock::GetTimeNowResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "GetTimeNow",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_time_server(&self) -> Result<alarm_clock::GetTimeServerResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "GetTimeServer",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_time_zone(&self) -> Result<alarm_clock::GetTimeZoneResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "GetTimeZone",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_time_zone_and_rule(&self) -> Result<alarm_clock::GetTimeZoneAndRuleResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "GetTimeZoneAndRule",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_time_zone_rule(
        &self,
        request: alarm_clock::GetTimeZoneRuleRequest,
    ) -> Result<alarm_clock::GetTimeZoneRuleResponse> {
        self.action(&alarm_clock::SERVICE_TYPE, "GetTimeZoneRule", request)
            .await
    }

    async fn list_alarms(&self) -> Result<alarm_clock::ListAlarmsResponse> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "ListAlarms",
            crate::soap::Unit {},
        )
        .await
    }

    async fn set_daily_index_refresh_time(
        &self,
        request: alarm_clock::SetDailyIndexRefreshTimeRequest,
    ) -> Result<()> {
        self.action(
            &alarm_clock::SERVICE_TYPE,
            "SetDailyIndexRefreshTime",
            request,
        )
        .await
    }

    async fn set_format(&self, request: alarm_clock::SetFormatRequest) -> Result<()> {
        self.action(&alarm_clock::SERVICE_TYPE, "SetFormat", request)
            .await
    }

    async fn set_time_now(&self, request: alarm_clock::SetTimeNowRequest) -> Result<()> {
        self.action(&alarm_clock::SERVICE_TYPE, "SetTimeNow", request)
            .await
    }

    async fn set_time_server(&self, request: alarm_clock::SetTimeServerRequest) -> Result<()> {
        self.action(&alarm_clock::SERVICE_TYPE, "SetTimeServer", request)
            .await
    }

    async fn set_time_zone(&self, request: alarm_clock::SetTimeZoneRequest) -> Result<()> {
        self.action(&alarm_clock::SERVICE_TYPE, "SetTimeZone", request)
            .await
    }

    async fn update_alarm(&self, request: alarm_clock::UpdateAlarmRequest) -> Result<()> {
        self.action(&alarm_clock::SERVICE_TYPE, "UpdateAlarm", request)
            .await
    }
}

impl AudioIn for SonosDevice {
    async fn get_audio_input_attributes(
        &self,
    ) -> Result<audio_in::GetAudioInputAttributesResponse> {
        self.action(
            &audio_in::SERVICE_TYPE,
            "GetAudioInputAttributes",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_line_in_level(&self) -> Result<audio_in::GetLineInLevelResponse> {
        self.action(
            &audio_in::SERVICE_TYPE,
            "GetLineInLevel",
            crate::soap::Unit {},
        )
        .await
    }

    async fn select_audio(&self, request: audio_in::SelectAudioRequest) -> Result<()> {
        self.action(&audio_in::SERVICE_TYPE, "SelectAudio", request)
            .await
    }

    async fn set_audio_input_attributes(
        &self,
        request: audio_in::SetAudioInputAttributesRequest,
    ) -> Result<()> {
        self.action(&audio_in::SERVICE_TYPE, "SetAudioInputAttributes", request)
            .await
    }

    async fn set_line_in_level(&self, request: audio_in::SetLineInLevelRequest) -> Result<()> {
        self.action(&audio_in::SERVICE_TYPE, "SetLineInLevel", request)
            .await
    }

    async fn start_transmission_to_group(
        &self,
        request: audio_in::StartTransmissionToGroupRequest,
    ) -> Result<audio_in::StartTransmissionToGroupResponse> {
        self.action(&audio_in::SERVICE_TYPE, "StartTransmissionToGroup", request)
            .await
    }

    async fn stop_transmission_to_group(
        &self,
        request: audio_in::StopTransmissionToGroupRequest,
    ) -> Result<()> {
        self.action(&audio_in::SERVICE_TYPE, "StopTransmissionToGroup", request)
            .await
    }
}

impl ConnectionManager for SonosDevice {
    async fn get_current_connection_ids(
        &self,
    ) -> Result<connection_manager::GetCurrentConnectionIdsResponse> {
        self.action(
            &connection_manager::SERVICE_TYPE,
            "GetCurrentConnectionIDs",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_current_connection_info(
        &self,
        request: connection_manager::GetCurrentConnectionInfoRequest,
    ) -> Result<connection_manager::GetCurrentConnectionInfoResponse> {
        self.action(
            &connection_manager::SERVICE_TYPE,
            "GetCurrentConnectionInfo",
            request,
        )
        .await
    }

    async fn get_protocol_info(&self) -> Result<connection_manager::GetProtocolInfoResponse> {
        self.action(
            &connection_manager::SERVICE_TYPE,
            "GetProtocolInfo",
            crate::soap::Unit {},
        )
        .await
    }
}

impl ContentDirectory for SonosDevice {
    async fn browse(
        &self,
        request: content_directory::BrowseRequest,
    ) -> Result<content_directory::BrowseResponse> {
        self.action(&content_directory::SERVICE_TYPE, "Browse", request)
            .await
    }

    async fn create_object(
        &self,
        request: content_directory::CreateObjectRequest,
    ) -> Result<content_directory::CreateObjectResponse> {
        self.action(&content_directory::SERVICE_TYPE, "CreateObject", request)
            .await
    }

    async fn destroy_object(&self, request: content_directory::DestroyObjectRequest) -> Result<()> {
        self.action(&content_directory::SERVICE_TYPE, "DestroyObject", request)
            .await
    }

    async fn find_prefix(
        &self,
        request: content_directory::FindPrefixRequest,
    ) -> Result<content_directory::FindPrefixResponse> {
        self.action(&content_directory::SERVICE_TYPE, "FindPrefix", request)
            .await
    }

    async fn get_album_artist_display_option(
        &self,
    ) -> Result<content_directory::GetAlbumArtistDisplayOptionResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetAlbumArtistDisplayOption",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_all_prefix_locations(
        &self,
        request: content_directory::GetAllPrefixLocationsRequest,
    ) -> Result<content_directory::GetAllPrefixLocationsResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetAllPrefixLocations",
            request,
        )
        .await
    }

    async fn get_browseable(&self) -> Result<content_directory::GetBrowseableResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetBrowseable",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_last_index_change(&self) -> Result<content_directory::GetLastIndexChangeResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetLastIndexChange",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_search_capabilities(
        &self,
    ) -> Result<content_directory::GetSearchCapabilitiesResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetSearchCapabilities",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_share_index_in_progress(
        &self,
    ) -> Result<content_directory::GetShareIndexInProgressResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetShareIndexInProgress",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_sort_capabilities(
        &self,
    ) -> Result<content_directory::GetSortCapabilitiesResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetSortCapabilities",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_system_update_id(&self) -> Result<content_directory::GetSystemUpdateIdResponse> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "GetSystemUpdateID",
            crate::soap::Unit {},
        )
        .await
    }

    async fn refresh_share_index(
        &self,
        request: content_directory::RefreshShareIndexRequest,
    ) -> Result<()> {
        self.action(
            &content_directory::SERVICE_TYPE,
            "RefreshShareIndex",
            request,
        )
        .await
    }

    async fn request_resort(&self, request: content_directory::RequestResortRequest) -> Result<()> {
        self.action(&content_directory::SERVICE_TYPE, "RequestResort", request)
            .await
    }

    async fn set_browseable(&self, request: content_directory::SetBrowseableRequest) -> Result<()> {
        self.action(&content_directory::SERVICE_TYPE, "SetBrowseable", request)
            .await
    }

    async fn update_object(&self, request: content_directory::UpdateObjectRequest) -> Result<()> {
        self.action(&content_directory::SERVICE_TYPE, "UpdateObject", request)
            .await
    }
}

impl DeviceProperties for SonosDevice {
    async fn add_bonded_zones(
        &self,
        request: device_properties::AddBondedZonesRequest,
    ) -> Result<()> {
        self.action(&device_properties::SERVICE_TYPE, "AddBondedZones", request)
            .await
    }

    async fn add_ht_satellite(
        &self,
        request: device_properties::AddHtSatelliteRequest,
    ) -> Result<()> {
        self.action(&device_properties::SERVICE_TYPE, "AddHTSatellite", request)
            .await
    }

    async fn create_stereo_pair(
        &self,
        request: device_properties::CreateStereoPairRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "CreateStereoPair",
            request,
        )
        .await
    }

    async fn enter_config_mode(
        &self,
        request: device_properties::EnterConfigModeRequest,
    ) -> Result<device_properties::EnterConfigModeResponse> {
        self.action(&device_properties::SERVICE_TYPE, "EnterConfigMode", request)
            .await
    }

    async fn exit_config_mode(
        &self,
        request: device_properties::ExitConfigModeRequest,
    ) -> Result<()> {
        self.action(&device_properties::SERVICE_TYPE, "ExitConfigMode", request)
            .await
    }

    async fn get_autoplay_linked_zones(
        &self,
        request: device_properties::GetAutoplayLinkedZonesRequest,
    ) -> Result<device_properties::GetAutoplayLinkedZonesResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetAutoplayLinkedZones",
            request,
        )
        .await
    }

    async fn get_autoplay_room_uuid(
        &self,
        request: device_properties::GetAutoplayRoomUuidRequest,
    ) -> Result<device_properties::GetAutoplayRoomUuidResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetAutoplayRoomUUID",
            request,
        )
        .await
    }

    async fn get_autoplay_volume(
        &self,
        request: device_properties::GetAutoplayVolumeRequest,
    ) -> Result<device_properties::GetAutoplayVolumeResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetAutoplayVolume",
            request,
        )
        .await
    }

    async fn get_button_lock_state(&self) -> Result<device_properties::GetButtonLockStateResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetButtonLockState",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_button_state(&self) -> Result<device_properties::GetButtonStateResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetButtonState",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_ht_forward_state(&self) -> Result<device_properties::GetHtForwardStateResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetHTForwardState",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_household_id(&self) -> Result<device_properties::GetHouseholdIdResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetHouseholdID",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_led_state(&self) -> Result<device_properties::GetLedStateResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetLEDState",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_use_autoplay_volume(
        &self,
        request: device_properties::GetUseAutoplayVolumeRequest,
    ) -> Result<device_properties::GetUseAutoplayVolumeResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetUseAutoplayVolume",
            request,
        )
        .await
    }

    async fn get_zone_attributes(&self) -> Result<device_properties::GetZoneAttributesResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetZoneAttributes",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_zone_info(&self) -> Result<device_properties::GetZoneInfoResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "GetZoneInfo",
            crate::soap::Unit {},
        )
        .await
    }

    async fn remove_bonded_zones(
        &self,
        request: device_properties::RemoveBondedZonesRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "RemoveBondedZones",
            request,
        )
        .await
    }

    async fn remove_ht_satellite(
        &self,
        request: device_properties::RemoveHtSatelliteRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "RemoveHTSatellite",
            request,
        )
        .await
    }

    async fn room_detection_start_chirping(
        &self,
        request: device_properties::RoomDetectionStartChirpingRequest,
    ) -> Result<device_properties::RoomDetectionStartChirpingResponse> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "RoomDetectionStartChirping",
            request,
        )
        .await
    }

    async fn room_detection_stop_chirping(
        &self,
        request: device_properties::RoomDetectionStopChirpingRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "RoomDetectionStopChirping",
            request,
        )
        .await
    }

    async fn separate_stereo_pair(
        &self,
        request: device_properties::SeparateStereoPairRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "SeparateStereoPair",
            request,
        )
        .await
    }

    async fn set_autoplay_linked_zones(
        &self,
        request: device_properties::SetAutoplayLinkedZonesRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "SetAutoplayLinkedZones",
            request,
        )
        .await
    }

    async fn set_autoplay_room_uuid(
        &self,
        request: device_properties::SetAutoplayRoomUuidRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "SetAutoplayRoomUUID",
            request,
        )
        .await
    }

    async fn set_autoplay_volume(
        &self,
        request: device_properties::SetAutoplayVolumeRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "SetAutoplayVolume",
            request,
        )
        .await
    }

    async fn set_button_lock_state(
        &self,
        request: device_properties::SetButtonLockStateRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "SetButtonLockState",
            request,
        )
        .await
    }

    async fn set_led_state(&self, request: device_properties::SetLedStateRequest) -> Result<()> {
        self.action(&device_properties::SERVICE_TYPE, "SetLEDState", request)
            .await
    }

    async fn set_use_autoplay_volume(
        &self,
        request: device_properties::SetUseAutoplayVolumeRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "SetUseAutoplayVolume",
            request,
        )
        .await
    }

    async fn set_zone_attributes(
        &self,
        request: device_properties::SetZoneAttributesRequest,
    ) -> Result<()> {
        self.action(
            &device_properties::SERVICE_TYPE,
            "SetZoneAttributes",
            request,
        )
        .await
    }
}

impl GroupManagement for SonosDevice {
    async fn add_member(
        &self,
        request: group_management::AddMemberRequest,
    ) -> Result<group_management::AddMemberResponse> {
        self.action(&group_management::SERVICE_TYPE, "AddMember", request)
            .await
    }

    async fn remove_member(&self, request: group_management::RemoveMemberRequest) -> Result<()> {
        self.action(&group_management::SERVICE_TYPE, "RemoveMember", request)
            .await
    }

    async fn report_track_buffering_result(
        &self,
        request: group_management::ReportTrackBufferingResultRequest,
    ) -> Result<()> {
        self.action(
            &group_management::SERVICE_TYPE,
            "ReportTrackBufferingResult",
            request,
        )
        .await
    }

    async fn set_source_area_ids(
        &self,
        request: group_management::SetSourceAreaIdsRequest,
    ) -> Result<()> {
        self.action(&group_management::SERVICE_TYPE, "SetSourceAreaIds", request)
            .await
    }
}

impl GroupRenderingControl for SonosDevice {
    async fn get_group_mute(
        &self,
        request: group_rendering_control::GetGroupMuteRequest,
    ) -> Result<group_rendering_control::GetGroupMuteResponse> {
        self.action(
            &group_rendering_control::SERVICE_TYPE,
            "GetGroupMute",
            request,
        )
        .await
    }

    async fn get_group_volume(
        &self,
        request: group_rendering_control::GetGroupVolumeRequest,
    ) -> Result<group_rendering_control::GetGroupVolumeResponse> {
        self.action(
            &group_rendering_control::SERVICE_TYPE,
            "GetGroupVolume",
            request,
        )
        .await
    }

    async fn set_group_mute(
        &self,
        request: group_rendering_control::SetGroupMuteRequest,
    ) -> Result<()> {
        self.action(
            &group_rendering_control::SERVICE_TYPE,
            "SetGroupMute",
            request,
        )
        .await
    }

    async fn set_group_volume(
        &self,
        request: group_rendering_control::SetGroupVolumeRequest,
    ) -> Result<()> {
        self.action(
            &group_rendering_control::SERVICE_TYPE,
            "SetGroupVolume",
            request,
        )
        .await
    }

    async fn set_relative_group_volume(
        &self,
        request: group_rendering_control::SetRelativeGroupVolumeRequest,
    ) -> Result<group_rendering_control::SetRelativeGroupVolumeResponse> {
        self.action(
            &group_rendering_control::SERVICE_TYPE,
            "SetRelativeGroupVolume",
            request,
        )
        .await
    }

    async fn snapshot_group_volume(
        &self,
        request: group_rendering_control::SnapshotGroupVolumeRequest,
    ) -> Result<()> {
        self.action(
            &group_rendering_control::SERVICE_TYPE,
            "SnapshotGroupVolume",
            request,
        )
        .await
    }
}

impl HTControl for SonosDevice {
    async fn commit_learned_ir_codes(
        &self,
        request: ht_control::CommitLearnedIrCodesRequest,
    ) -> Result<()> {
        self.action(&ht_control::SERVICE_TYPE, "CommitLearnedIRCodes", request)
            .await
    }

    async fn get_ir_repeater_state(&self) -> Result<ht_control::GetIrRepeaterStateResponse> {
        self.action(
            &ht_control::SERVICE_TYPE,
            "GetIRRepeaterState",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_led_feedback_state(&self) -> Result<ht_control::GetLedFeedbackStateResponse> {
        self.action(
            &ht_control::SERVICE_TYPE,
            "GetLEDFeedbackState",
            crate::soap::Unit {},
        )
        .await
    }

    async fn identify_ir_remote(&self, request: ht_control::IdentifyIrRemoteRequest) -> Result<()> {
        self.action(&ht_control::SERVICE_TYPE, "IdentifyIRRemote", request)
            .await
    }

    async fn is_remote_configured(&self) -> Result<ht_control::IsRemoteConfiguredResponse> {
        self.action(
            &ht_control::SERVICE_TYPE,
            "IsRemoteConfigured",
            crate::soap::Unit {},
        )
        .await
    }

    async fn learn_ir_code(&self, request: ht_control::LearnIrCodeRequest) -> Result<()> {
        self.action(&ht_control::SERVICE_TYPE, "LearnIRCode", request)
            .await
    }

    async fn set_ir_repeater_state(
        &self,
        request: ht_control::SetIrRepeaterStateRequest,
    ) -> Result<()> {
        self.action(&ht_control::SERVICE_TYPE, "SetIRRepeaterState", request)
            .await
    }

    async fn set_led_feedback_state(
        &self,
        request: ht_control::SetLedFeedbackStateRequest,
    ) -> Result<()> {
        self.action(&ht_control::SERVICE_TYPE, "SetLEDFeedbackState", request)
            .await
    }
}

impl MusicServices for SonosDevice {
    async fn get_session_id(
        &self,
        request: music_services::GetSessionIdRequest,
    ) -> Result<music_services::GetSessionIdResponse> {
        self.action(&music_services::SERVICE_TYPE, "GetSessionId", request)
            .await
    }

    async fn list_available_services(
        &self,
    ) -> Result<music_services::ListAvailableServicesResponse> {
        self.action(
            &music_services::SERVICE_TYPE,
            "ListAvailableServices",
            crate::soap::Unit {},
        )
        .await
    }

    async fn update_available_services(&self) -> Result<()> {
        self.action(
            &music_services::SERVICE_TYPE,
            "UpdateAvailableServices",
            crate::soap::Unit {},
        )
        .await
    }
}

impl QPlay for SonosDevice {
    async fn q_play_auth(
        &self,
        request: q_play::QPlayAuthRequest,
    ) -> Result<q_play::QPlayAuthResponse> {
        self.action(&q_play::SERVICE_TYPE, "QPlayAuth", request)
            .await
    }
}

impl Queue for SonosDevice {
    async fn add_multiple_uris(
        &self,
        request: queue::AddMultipleUrisRequest,
    ) -> Result<queue::AddMultipleUrisResponse> {
        self.action(&queue::SERVICE_TYPE, "AddMultipleURIs", request)
            .await
    }

    async fn add_uri(&self, request: queue::AddUriRequest) -> Result<queue::AddUriResponse> {
        self.action(&queue::SERVICE_TYPE, "AddURI", request).await
    }

    async fn attach_queue(
        &self,
        request: queue::AttachQueueRequest,
    ) -> Result<queue::AttachQueueResponse> {
        self.action(&queue::SERVICE_TYPE, "AttachQueue", request)
            .await
    }

    async fn backup(&self) -> Result<()> {
        self.action(&queue::SERVICE_TYPE, "Backup", crate::soap::Unit {})
            .await
    }

    async fn browse(&self, request: queue::BrowseRequest) -> Result<queue::BrowseResponse> {
        self.action(&queue::SERVICE_TYPE, "Browse", request).await
    }

    async fn create_queue(
        &self,
        request: queue::CreateQueueRequest,
    ) -> Result<queue::CreateQueueResponse> {
        self.action(&queue::SERVICE_TYPE, "CreateQueue", request)
            .await
    }

    async fn remove_all_tracks(
        &self,
        request: queue::RemoveAllTracksRequest,
    ) -> Result<queue::RemoveAllTracksResponse> {
        self.action(&queue::SERVICE_TYPE, "RemoveAllTracks", request)
            .await
    }

    async fn remove_track_range(
        &self,
        request: queue::RemoveTrackRangeRequest,
    ) -> Result<queue::RemoveTrackRangeResponse> {
        self.action(&queue::SERVICE_TYPE, "RemoveTrackRange", request)
            .await
    }

    async fn reorder_tracks(
        &self,
        request: queue::ReorderTracksRequest,
    ) -> Result<queue::ReorderTracksResponse> {
        self.action(&queue::SERVICE_TYPE, "ReorderTracks", request)
            .await
    }

    async fn replace_all_tracks(
        &self,
        request: queue::ReplaceAllTracksRequest,
    ) -> Result<queue::ReplaceAllTracksResponse> {
        self.action(&queue::SERVICE_TYPE, "ReplaceAllTracks", request)
            .await
    }

    async fn save_as_sonos_playlist(
        &self,
        request: queue::SaveAsSonosPlaylistRequest,
    ) -> Result<queue::SaveAsSonosPlaylistResponse> {
        self.action(&queue::SERVICE_TYPE, "SaveAsSonosPlaylist", request)
            .await
    }
}

impl RenderingControl for SonosDevice {
    async fn get_bass(
        &self,
        request: rendering_control::GetBassRequest,
    ) -> Result<rendering_control::GetBassResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetBass", request)
            .await
    }

    async fn get_eq(
        &self,
        request: rendering_control::GetEqRequest,
    ) -> Result<rendering_control::GetEqResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetEQ", request)
            .await
    }

    async fn get_headphone_connected(
        &self,
        request: rendering_control::GetHeadphoneConnectedRequest,
    ) -> Result<rendering_control::GetHeadphoneConnectedResponse> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "GetHeadphoneConnected",
            request,
        )
        .await
    }

    async fn get_loudness(
        &self,
        request: rendering_control::GetLoudnessRequest,
    ) -> Result<rendering_control::GetLoudnessResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetLoudness", request)
            .await
    }

    async fn get_mute(
        &self,
        request: rendering_control::GetMuteRequest,
    ) -> Result<rendering_control::GetMuteResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetMute", request)
            .await
    }

    async fn get_output_fixed(
        &self,
        request: rendering_control::GetOutputFixedRequest,
    ) -> Result<rendering_control::GetOutputFixedResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetOutputFixed", request)
            .await
    }

    async fn get_room_calibration_status(
        &self,
        request: rendering_control::GetRoomCalibrationStatusRequest,
    ) -> Result<rendering_control::GetRoomCalibrationStatusResponse> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "GetRoomCalibrationStatus",
            request,
        )
        .await
    }

    async fn get_supports_output_fixed(
        &self,
        request: rendering_control::GetSupportsOutputFixedRequest,
    ) -> Result<rendering_control::GetSupportsOutputFixedResponse> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "GetSupportsOutputFixed",
            request,
        )
        .await
    }

    async fn get_treble(
        &self,
        request: rendering_control::GetTrebleRequest,
    ) -> Result<rendering_control::GetTrebleResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetTreble", request)
            .await
    }

    async fn get_volume(
        &self,
        request: rendering_control::GetVolumeRequest,
    ) -> Result<rendering_control::GetVolumeResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetVolume", request)
            .await
    }

    async fn get_volume_db(
        &self,
        request: rendering_control::GetVolumeDbRequest,
    ) -> Result<rendering_control::GetVolumeDbResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "GetVolumeDB", request)
            .await
    }

    async fn get_volume_db_range(
        &self,
        request: rendering_control::GetVolumeDbRangeRequest,
    ) -> Result<rendering_control::GetVolumeDbRangeResponse> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "GetVolumeDBRange",
            request,
        )
        .await
    }

    async fn ramp_to_volume(
        &self,
        request: rendering_control::RampToVolumeRequest,
    ) -> Result<rendering_control::RampToVolumeResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "RampToVolume", request)
            .await
    }

    async fn reset_basic_eq(
        &self,
        request: rendering_control::ResetBasicEqRequest,
    ) -> Result<rendering_control::ResetBasicEqResponse> {
        self.action(&rendering_control::SERVICE_TYPE, "ResetBasicEQ", request)
            .await
    }

    async fn reset_ext_eq(&self, request: rendering_control::ResetExtEqRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "ResetExtEQ", request)
            .await
    }

    async fn restore_volume_prior_to_ramp(
        &self,
        request: rendering_control::RestoreVolumePriorToRampRequest,
    ) -> Result<()> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "RestoreVolumePriorToRamp",
            request,
        )
        .await
    }

    async fn set_bass(&self, request: rendering_control::SetBassRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetBass", request)
            .await
    }

    async fn set_channel_map(
        &self,
        request: rendering_control::SetChannelMapRequest,
    ) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetChannelMap", request)
            .await
    }

    async fn set_eq(&self, request: rendering_control::SetEqRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetEQ", request)
            .await
    }

    async fn set_loudness(&self, request: rendering_control::SetLoudnessRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetLoudness", request)
            .await
    }

    async fn set_mute(&self, request: rendering_control::SetMuteRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetMute", request)
            .await
    }

    async fn set_output_fixed(
        &self,
        request: rendering_control::SetOutputFixedRequest,
    ) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetOutputFixed", request)
            .await
    }

    async fn set_relative_volume(
        &self,
        request: rendering_control::SetRelativeVolumeRequest,
    ) -> Result<rendering_control::SetRelativeVolumeResponse> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "SetRelativeVolume",
            request,
        )
        .await
    }

    async fn set_room_calibration_status(
        &self,
        request: rendering_control::SetRoomCalibrationStatusRequest,
    ) -> Result<()> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "SetRoomCalibrationStatus",
            request,
        )
        .await
    }

    async fn set_room_calibration_x(
        &self,
        request: rendering_control::SetRoomCalibrationXRequest,
    ) -> Result<()> {
        self.action(
            &rendering_control::SERVICE_TYPE,
            "SetRoomCalibrationX",
            request,
        )
        .await
    }

    async fn set_treble(&self, request: rendering_control::SetTrebleRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetTreble", request)
            .await
    }

    async fn set_volume(&self, request: rendering_control::SetVolumeRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetVolume", request)
            .await
    }

    async fn set_volume_db(&self, request: rendering_control::SetVolumeDbRequest) -> Result<()> {
        self.action(&rendering_control::SERVICE_TYPE, "SetVolumeDB", request)
            .await
    }
}

impl SystemProperties for SonosDevice {
    async fn add_account_x(
        &self,
        request: system_properties::AddAccountXRequest,
    ) -> Result<system_properties::AddAccountXResponse> {
        self.action(&system_properties::SERVICE_TYPE, "AddAccountX", request)
            .await
    }

    async fn add_o_auth_account_x(
        &self,
        request: system_properties::AddOAuthAccountXRequest,
    ) -> Result<system_properties::AddOAuthAccountXResponse> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "AddOAuthAccountX",
            request,
        )
        .await
    }

    async fn do_post_update_tasks(&self) -> Result<()> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "DoPostUpdateTasks",
            crate::soap::Unit {},
        )
        .await
    }

    async fn edit_account_md(
        &self,
        request: system_properties::EditAccountMdRequest,
    ) -> Result<()> {
        self.action(&system_properties::SERVICE_TYPE, "EditAccountMd", request)
            .await
    }

    async fn edit_account_password_x(
        &self,
        request: system_properties::EditAccountPasswordXRequest,
    ) -> Result<()> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "EditAccountPasswordX",
            request,
        )
        .await
    }

    async fn enable_rdm(&self, request: system_properties::EnableRdmRequest) -> Result<()> {
        self.action(&system_properties::SERVICE_TYPE, "EnableRDM", request)
            .await
    }

    async fn get_rdm(&self) -> Result<system_properties::GetRdmResponse> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "GetRDM",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_string(
        &self,
        request: system_properties::GetStringRequest,
    ) -> Result<system_properties::GetStringResponse> {
        self.action(&system_properties::SERVICE_TYPE, "GetString", request)
            .await
    }

    async fn get_web_code(
        &self,
        request: system_properties::GetWebCodeRequest,
    ) -> Result<system_properties::GetWebCodeResponse> {
        self.action(&system_properties::SERVICE_TYPE, "GetWebCode", request)
            .await
    }

    async fn provision_credentialed_trial_account_x(
        &self,
        request: system_properties::ProvisionCredentialedTrialAccountXRequest,
    ) -> Result<system_properties::ProvisionCredentialedTrialAccountXResponse> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "ProvisionCredentialedTrialAccountX",
            request,
        )
        .await
    }

    async fn refresh_account_credentials_x(
        &self,
        request: system_properties::RefreshAccountCredentialsXRequest,
    ) -> Result<()> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "RefreshAccountCredentialsX",
            request,
        )
        .await
    }

    async fn remove(&self, request: system_properties::RemoveRequest) -> Result<()> {
        self.action(&system_properties::SERVICE_TYPE, "Remove", request)
            .await
    }

    async fn remove_account(&self, request: system_properties::RemoveAccountRequest) -> Result<()> {
        self.action(&system_properties::SERVICE_TYPE, "RemoveAccount", request)
            .await
    }

    async fn replace_account_x(
        &self,
        request: system_properties::ReplaceAccountXRequest,
    ) -> Result<system_properties::ReplaceAccountXResponse> {
        self.action(&system_properties::SERVICE_TYPE, "ReplaceAccountX", request)
            .await
    }

    async fn reset_third_party_credentials(&self) -> Result<()> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "ResetThirdPartyCredentials",
            crate::soap::Unit {},
        )
        .await
    }

    async fn set_account_nickname_x(
        &self,
        request: system_properties::SetAccountNicknameXRequest,
    ) -> Result<()> {
        self.action(
            &system_properties::SERVICE_TYPE,
            "SetAccountNicknameX",
            request,
        )
        .await
    }

    async fn set_string(&self, request: system_properties::SetStringRequest) -> Result<()> {
        self.action(&system_properties::SERVICE_TYPE, "SetString", request)
            .await
    }
}

impl VirtualLineIn for SonosDevice {
    async fn next(&self, request: virtual_line_in::NextRequest) -> Result<()> {
        self.action(&virtual_line_in::SERVICE_TYPE, "Next", request)
            .await
    }

    async fn pause(&self, request: virtual_line_in::PauseRequest) -> Result<()> {
        self.action(&virtual_line_in::SERVICE_TYPE, "Pause", request)
            .await
    }

    async fn play(&self, request: virtual_line_in::PlayRequest) -> Result<()> {
        self.action(&virtual_line_in::SERVICE_TYPE, "Play", request)
            .await
    }

    async fn previous(&self, request: virtual_line_in::PreviousRequest) -> Result<()> {
        self.action(&virtual_line_in::SERVICE_TYPE, "Previous", request)
            .await
    }

    async fn set_volume(&self, request: virtual_line_in::SetVolumeRequest) -> Result<()> {
        self.action(&virtual_line_in::SERVICE_TYPE, "SetVolume", request)
            .await
    }

    async fn start_transmission(
        &self,
        request: virtual_line_in::StartTransmissionRequest,
    ) -> Result<virtual_line_in::StartTransmissionResponse> {
        self.action(&virtual_line_in::SERVICE_TYPE, "StartTransmission", request)
            .await
    }

    async fn stop(&self, request: virtual_line_in::StopRequest) -> Result<()> {
        self.action(&virtual_line_in::SERVICE_TYPE, "Stop", request)
            .await
    }

    async fn stop_transmission(
        &self,
        request: virtual_line_in::StopTransmissionRequest,
    ) -> Result<()> {
        self.action(&virtual_line_in::SERVICE_TYPE, "StopTransmission", request)
            .await
    }
}

impl ZoneGroupTopology for SonosDevice {
    async fn begin_software_update(
        &self,
        request: zone_group_topology::BeginSoftwareUpdateRequest,
    ) -> Result<()> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "BeginSoftwareUpdate",
            request,
        )
        .await
    }

    async fn check_for_update(
        &self,
        request: zone_group_topology::CheckForUpdateRequest,
    ) -> Result<zone_group_topology::CheckForUpdateResponse> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "CheckForUpdate",
            request,
        )
        .await
    }

    async fn get_zone_group_attributes(
        &self,
    ) -> Result<zone_group_topology::GetZoneGroupAttributesResponse> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "GetZoneGroupAttributes",
            crate::soap::Unit {},
        )
        .await
    }

    async fn get_zone_group_state(&self) -> Result<zone_group_topology::GetZoneGroupStateResponse> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "GetZoneGroupState",
            crate::soap::Unit {},
        )
        .await
    }

    async fn register_mobile_device(
        &self,
        request: zone_group_topology::RegisterMobileDeviceRequest,
    ) -> Result<()> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "RegisterMobileDevice",
            request,
        )
        .await
    }

    async fn report_alarm_started_running(&self) -> Result<()> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "ReportAlarmStartedRunning",
            crate::soap::Unit {},
        )
        .await
    }

    async fn report_unresponsive_device(
        &self,
        request: zone_group_topology::ReportUnresponsiveDeviceRequest,
    ) -> Result<()> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "ReportUnresponsiveDevice",
            request,
        )
        .await
    }

    async fn submit_diagnostics(
        &self,
        request: zone_group_topology::SubmitDiagnosticsRequest,
    ) -> Result<zone_group_topology::SubmitDiagnosticsResponse> {
        self.action(
            &zone_group_topology::SERVICE_TYPE,
            "SubmitDiagnostics",
            request,
        )
        .await
    }
}

/// The prelude makes it convenient to use the methods of `SonosDevice`.
/// Intended usage is `use sonos::prelude::*;` and then you don't have
/// to worry about importing the individual service traits.
pub mod prelude {
    pub use super::{
        AVTransport, AlarmClock, AudioIn, ConnectionManager, ContentDirectory, DeviceProperties,
        GroupManagement, GroupRenderingControl, HTControl, MusicServices, QPlay, Queue,
        RenderingControl, SystemProperties, VirtualLineIn, ZoneGroupTopology,
    };
}
